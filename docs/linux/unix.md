---
layout: default
title: unix
has_children: false
permalink: /docs/kb/linux/unix
parent: linux
grand_parent: kb
has_toc: true
---
Общие заметки про UNIX, Linux
<details close markdown="block">
  <summary>
    Содержание
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

# rsync
---

Основные примеры использования

1. Копирование локального каталога в другую директорию:
```
rsync [опции] /путь/к/источнику/ /путь/к/назначению/
```

2. Копирование локального каталога на удалённый сервер через SSH:
```
rsync [опции] /путь/к/источнику/ пользователь@удалённый_хост:/путь/к/назначению/
```

3. Копирование каталога с удалённого сервера на локальный хост через SSH:
```
rsync [опции] пользователь@удалённый_хост:/путь/к/источнику/ /путь/к/назначению/
```



---

Полезные опции


---

Расширенные примеры

1. Синхронизация с исключением определённых файлов и каталогов:
```
rsync -av --exclude="*.tmp" --exclude="backup/" /источник/ /назначение/
```

2. Ограничение пропускной способности до 500 КБ/с:
```
rsync -av --bwlimit=500 /источник/ пользователь@удалённый_хост:/назначение/
```

3. Удаление файлов в месте назначения, которых больше нет в источнике:
```
rsync -av --delete /источник/ /назначение/
```

4. Резервное копирование с сохранением удалённых файлов в отдельной директории:
```
rsync -av --delete --backup --backup-dir=/backup/ /источник/ /назначение/
```

5. Просмотр изменений без выполнения передачи:
```
rsync -avn /источник/ /назначение/
```



---

Безопасность при использовании

1. Используйте SSH для удалённых синхронизаций. Добавьте ключ -e ssh, чтобы принудительно использовать SSH:
```
rsync -av -e ssh /источник/ пользователь@удалённый_хост:/назначение/
```

2. Ограничьте права доступа к данным. Убедитесь, что данные доступны только авторизованным пользователям.


3. Проверяйте ключи SSH. Используйте ключи SSH с паролем или настройте систему с использованием ssh-agent.


4. Логируйте операции. Добавьте >> /var/log/rsync.log 2>&1 в конец команды для записи логов.


5. Используйте опцию --checksum, чтобы дополнительно проверять данные. Это полезно для критически важных данных:
```
rsync -av --checksum /источник/ пользователь@удалённый_хост:/назначение/
```



# alias

### Полезные алиасы для оболочки Linux

- `alias ..='cd ..'` – Перейти на один уровень выше.
- `alias ...='cd ../..'` – Перейти на два уровня выше.
- `alias ....='cd ../../..'` – Перейти на три уровня выше.
- `alias ll='ls -al --color=auto'` – Показать файлы с подробной информацией.
- `alias lt='ls -ltr'` – Показать файлы в порядке модификации по возрастанию.
- `mkd() { mkdir -p "$1" && cd "$1"; }` – Создать директорию и сразу войти в нее.
- `alias rm='rm -i'` – Запрашивать подтверждение перед удалением файлов.
- `alias du='du -ch --max-depth=1'` – Подвести итоги использования диска по директориям.
- `alias mem='free -h'` – Показать использование памяти.
- `alias topcpu="ps -eo pid,cmd,%mem,%cpu --sort=-%cpu | head"` – Показать процессы с максимальной загрузкой CPU.
- `alias topmem="ps -eo pid,cmd,%mem,%cpu --sort=-%mem | head"` – Показать процессы с максимальным использованием памяти.
- `alias psg="ps aux | grep -v grep | grep -i"` – Найти процессы по имени или ключевому слову.
- `alias f="find . -type f -name"` – Найти файлы.
- `alias grep='grep --color=auto -i'` – Нечувствительный к регистру `grep` с цветным выводом.
- `alias reload='source ~/.bashrc'` – Перезагрузить конфигурацию оболочки.
- `alias hgrep='history | grep'` – Искать в истории команд оболочки.
- `alias chown='chown --preserve-root'` – Предотвратить случайное применение к корню.
- `alias chmod='chmod --preserve-root'` – Предотвратить случайное применение к корню.
- `alias chgrp='chgrp --preserve-root'` – Предотвратить случайное применение к корню.
- `alias ports='sudo ss -tulnap'` – Показать все открытые системные порты.
- `ipa() { ip -4 a show "$1" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'; }` – Показать IP-адрес интерфейса.
- `alias cpv='rsync -ah --info=progress2'` – Копировать файлы с индикатором прогресса.
- `alias update='sudo apt update && sudo apt upgrade -y'` – Обновить системы на базе Debian.
- `alias clean='sudo apt autoremove && sudo apt clean'` – Очистить неиспользуемые пакеты и кеш.
- `alias status='sudo systemctl status'` – Проверить статус службы systemd.
- `alias restart='sudo systemctl restart'` – Перезапустить службу systemd.
- `alias please='sudo !!'` – Повторить последнюю команду с правами суперпользователя.

# Установка ACL
```bash
apt install acl
```
## Проверка установленных ACL
```bash
getfacl /var/run/docker.sock
```
## Установка ACL для файла
```bash
setfacl -m u:zabbix:rw /var/run/docker.sock
```
# Поиск информации о завершении, перезагрузки системы 

### Описание команд для диагностики причины завершения работы сервера

#### 1\. Поиск последних событий завершения работы и перезагрузки:
```
last -x | head | tac- last -x
```
last -x \| head \| tac- last -x — показывает историю всех событий завершения работы (shutdown), перезагрузок (reboot), а также запусков и остановок сервисов.

* head — выводит первые 10 строк истории (для краткого обзора).
* tac — переворачивает вывод, показывая последние события в начале.

> Эта команда помогает быстро получить хронологию последних действий сервера. Чтобы улучшить, можно увеличить количество строк или использовать grep для фильтрации нужных событий.

#### 2\. Детализированный поиск завершений работы:
```
last -x -F shutdown -F
```

last -x -F shutdown- -F — выводит подробные временные метки для каждого события.

* shutdown — фильтрует события, относящиеся только к завершению работы системы.

> Команда поможет увидеть, когда именно произошла остановка системы. Для расширения информации можно добавить reboot в фильтр, чтобы получить и события перезагрузки.

#### 3\. Поиск событий завершения работы и перезагрузки с контекстом:
```
last -x | grep -C1 'shutdown|reboot' | head- grep -C1 'shutdown|reboot'
```

last -x \| grep -C1 'shutdown\|reboot' \| head- grep -C1 'shutdown\|reboot' — ищет строки с упоминанием shutdown или reboot, выводя одну строку контекста до и после найденной строки.

* head — ограничивает вывод первыми 10 результатами.

> Это полезно для поиска событий завершения работы или перезагрузки, включая события, которые произошли непосредственно перед или после них.

#### 4\. Поиск сообщений о завершении работы и проблемах с питанием:
```
sudo grep -iva ': starting|kernel: .: Power Button|watching system buttons|Stopped Cleaning Up|Started Crash recovery kernel' /var/log/messages /var/log/syslog /var/log/apcupsd | grep -iw 'recover[a-z]|power[a-z]|shut[a-z ]*down|rsyslogd|ups'
```
 
sudo grep -iva ': starting\|kernel: .: Power Button\|watching system buttons\|Stopped Cleaning Up\|Started Crash recovery kernel' /var/log/messages /var/log/syslog /var/log/apcupsd \| grep -iw 'recover[a-z]*\|power\[a-z\]*\|shut[a-z ]\*down\|rsyslogd\|ups'- sudo — команда требует привилегий администратора для чтения логов.

* grep -iva — исключает из вывода строки, содержащие часто встречающиеся, но неважные сообщения (например, начало работы сервисов или нажатие кнопки питания).
* /var/log/messages /var/log/syslog /var/log/apcupsd — файлы журналов, где может быть полезная информация о завершении работы системы.
* grep -iw 'recover[a-z]*\|power\[a-z\]*\|shut[a-z ]\*down\|rsyslogd\|ups' — ищет слова, связанные с завершением работы, сбоями питания, восстановлением, системой логирования или источником бесперебойного питания (UPS).

> Эта команда помогает сузить область поиска к событиям, связанным с отключением питания, перегревом или проблемами с источником питания. Можно дополнительно уточнять шаблоны поиска для выявления других возможных причин.

### Что можно улучшить:
```
journalctl -b -1 _COMM=systemd-logind | grep -i 'poweroff|reboot'
```

* Поиск пользователя, выполнившего команду завершения работы, можно добавить с помощью:
journalctl -b -1 _COMM=systemd-logind \| grep -i 'poweroff\|reboot'  Это поможет выявить, какой пользователь инициировал отключение или перезагрузку.
```
grep -i "thermal|overheat" /var/log/syslog
```

* Информацию о перегреве можно искать в журналах с помощью:
grep -i "thermal\|overheat" /var/log/syslog  Это поможет найти сообщения о проблемах с температурой.
```
sudo grep -i "shutdown\|reboot\|poweroff" /var/log/syslog
```


# Менеджер Логических Томов (LVM) в Linux

Файловая система находится поверх логического тома и будет форматирована под определённый тип файловой системы (например, vfat, xfs, ext4). Логические тома могут монтироваться в любом месте системы.

#### Компоненты LVM:
- **Файловая система**: `/home`, `/`, `/mnt/backups`
- **Логические тома**: `lv_home`, `lv_root`, `lv_backups`, unallocated (неразмеченный)
- **Группы томов (VG)**: `vg_system`, `vg_others`
- **Физические тома (PV)**: `/dev/vda1`, `/dev/vda2`, `/dev/vda3`, `/dev/vda4`, `/dev/vda5`
- **Разделы (Partitions)**: `/dev/vda1`, `/dev/vda2`
- **Жёсткие диски**: Физические устройства хранения данных, с которыми связаны физические тома.

#### Команды управления группами томов:

| Команда         | Описание                                             |
|-----------------|------------------------------------------------------|
| `vgcreate`      | Создать группу томов                                 |
| `vgscan`        | Поиск всех групп томов                               |
| `vgdisplay`     | Отобразить информацию о группах томов                |
| `vgextend`      | Добавить физические тома в существующую группу       |
| `vgreduce`      | Удалить физические тома из группы томов              |
| `vgrename`      | Переименовать группу томов                           |
| `vgchange`      | Изменить атрибуты группы томов                       |
| `vgck`          | Проверить целостность группы томов                   |
| `vgmerge`       | Объединить группы томов                              |
| `vgsplit`       | Разделить одну группу томов на две                   |
| `vgcfgbackup`   | Создать резервную копию конфигурации группы томов    |
| `vgcfgrestore`  | Восстановить конфигурацию из резервной копии         |
| `vgexport`      | Экспортировать группу томов                          |
| `vgimport`      | Импортировать группу томов                           |
| `vgmknodes`     | Воссоздать специальные файлы устройств в `/dev`      |

#### Команды управления физическими томами:

| Команда          | Описание                                                   |
|------------------|------------------------------------------------------------|
| `pvcreate`       | Инициализировать диск или раздел для использования как физический том |
| `pvscan`         | Сканировать все диски на предмет наличия физических томов   |
| `pvdisplay`      | Отобразить информацию о физических томах                    |
| `pvresize`       | Изменить размер физического тома                            |
| `pvmove`         | Переместить данные с одного физического тома на другой      |
| `pvck`           | Проверить метаданные физического тома                       |
| `pvremove`       | Удалить метаданные LVM с физического тома                   |
| `pvchange`       | Изменить атрибуты физического тома                          |

#### Команды управления логическими томами:

| Команда           | Описание                                                  |
|-------------------|-----------------------------------------------------------|
| `lvcreate`        | Создать новый логический том                               |
| `lvscan`          | Сканировать все логические тома                            |
| `lvdisplay`       | Отобразить информацию о логических томах                   |
| `lvextend`        | Увеличить размер логического тома                          |
| `lvreduce`        | Уменьшить размер логического тома                          |
| `lvremove`        | Удалить логический том                                     |
| `lvrename`        | Переименовать логический том                               |
| `lvchange`        | Изменить атрибуты логического тома                         |
| `lvconvert`       | Преобразовать логический том (например, в RAID или другой формат) |

#### Примеры использования команд:

1. **Создание физического тома**:
   ```bash
   sudo pvcreate /dev/vda1 /dev/vda2 /dev/vda3 /dev/vda4 /dev/vda5
   ```

2. **Создание группы томов**:
   ```bash
   sudo vgcreate vg_system /dev/vda1 /dev/vda2
   sudo vgcreate vg_others /dev/vda3 /dev/vda4 /dev/vda5
   ```

3. **Создание логических томов**:
   ```bash
   sudo lvcreate -L 20GB -n lv_home vg_system
   sudo lvcreate -L 35GB -n lv_root vg_system
   sudo lvcreate -L 70GB -n lv_backups vg_others
   ```

#### Дополнения от эксперта:
- **LVM снапшоты**: LVM поддерживает создание снапшотов логических томов, что позволяет делать резервные копии файловой системы на уровне томов. Это полезно для резервного копирования и восстановления данных в случае сбоев.
- **LVM кеширование**: LVM позволяет кешировать данные физического тома на SSD для повышения производительности.
- **RAID с LVM**: Можно использовать LVM для объединения нескольких физических томов в RAID-массивы, что обеспечивает отказоустойчивость и распределение нагрузки на диски.

#### Полезные команды для управления снапшотами:

| Команда           | Описание                                                 |
|-------------------|----------------------------------------------------------|
| `lvcreate -s`     | Создать снапшот логического тома                         |
| `lvremove`        | Удалить снапшот                                          |
| `lvconvert --merge`| Восстановить снапшот до исходного тома                  |

# history 
### 1. **Очистка текущей сессии Bash**
Чтобы очистить историю команд в текущей сессии:

```bash
history -c
```
Это удалит историю команд только для текущей сессии. Однако если вы просто выполните `history -c`, история сессии может быть записана обратно на диск при завершении работы терминала.

Чтобы предотвратить это, выполните также:
```bash
history -w
```
Это перезапишет файл истории без удаленных команд.

### 2. **Полная очистка файла истории**
Вы можете вручную очистить файл истории (`.bash_history`), который хранится в домашней директории пользователя.

Очистите файл с помощью команды:
```bash
cat /dev/null > ~/.bash_history
```
Либо:
```bash
> ~/.bash_history
```
После этого рекомендуется также выполнить:
```bash
history -c
history -w
```
Это гарантирует, что история очищена как в сессии, так и на диске.

### 3. **Отключение записи истории**
Чтобы временно отключить запись истории команд в текущей сессии:
```bash
unset HISTFILE
```
Это предотвратит запись команд в файл истории (`~/.bash_history`), но они все еще будут храниться в памяти текущей сессии до выхода.

### 4. **Удаление отдельных записей из истории**
Чтобы удалить одну или несколько конкретных строк из истории, можно использовать:
```bash
history -d <номер_строки>
```
Например, чтобы удалить пятую команду из истории:
```bash
history -d 5
```
Чтобы увидеть список команд с их номерами, используйте команду `history`.

### 5. **Отключение истории команд навсегда**
Если вы хотите, чтобы команды не сохранялись в истории, можно настроить это в файле `~/.bashrc`, добавив следующие строки:
```bash
unset HISTFILE
HISTSIZE=0
HISTFILESIZE=0
```
Это отключит сохранение истории в файл и установит максимальный размер истории в 0 команд.

# auditd
## Chapitre 12. Auditing the system
<https://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/9/html/security_hardening/auditing-the-system_security-hardening>
## Linux audit userspace repository
<https://github.com/linux-audit/audit-userspace>


# Устранение неполадок сети на Linux
## Уровень транспортный (Layer 4)
### 1. `ss -tunlp`
**Описание:** Проверка, открыты ли правильные IP/порты на локальном хосте для прослушивания.

**Пример:**
```bash
ss -tunlp
```

### 2. `nc -zv 10.10.0.1 80`
**Описание:** Проверка, открыт ли TCP порт 80 на удаленном хосте по адресу 10.10.0.1. Используйте `-u` для проверки UDP.

**Пример:**
```bash
nc -zv 10.10.0.1 80
```

---

## Сетевой уровень (Layer 3)
### 3. `ip -br address show`
**Описание:** Проверка, назначен ли валидный IP-адрес основному сетевому интерфейсу.

**Пример:**
```bash
ip -br address show
```

### 4. `ping 8.8.8.8`
**Описание:** Проверка доступности удаленного IP 8.8.8.8 через основной сетевой интерфейс.

**Пример:**
```bash
ping 8.8.8.8
```

### 5. `traceroute 8.8.8.8`
**Описание:** Проверка маршрута до удаленного IP, если он доступен.

**Пример:**
```bash
traceroute 8.8.8.8
```

### 6. `ip route show`
**Описание:** Проверка, правильно ли настроены маршруты и шлюз по умолчанию.

**Пример:**
```bash
ip route show
```

### 7. `dig www.google.com`
**Описание:** Проверка, работает ли DNS сервер по умолчанию и правильно ли настроена система разрешения имен.

**Пример:**
```bash
dig www.google.com
```

### 8. `arp-scan -I eth0 -l`
**Описание:** Проверка, нет ли конфликтов IP-адресов в локальной сети.

**Пример:**
```bash
arp-scan -I eth0 -l
```

---

## Канальный уровень (Layer 2)
### 9. `ip neighbor show`
**Описание:** Проверка, найден ли корректный MAC-адрес шлюза по умолчанию в локальной таблице ARP.

**Пример:**
```bash
ip neighbor show
```

### 10. `tcpdump -i eth0 -nn -e`
**Описание:** Просмотр заголовков пакетов 2-го уровня, таких как MAC-адреса и информация о VLAN.

**Пример:**
```bash
tcpdump -i eth0 -nn -e
```

---

## Физический уровень (Layer 1)
### 11. `ip -br link show`
**Описание:** Проверка, активен ли физический канал (ссылка).

**Пример:**
```bash
ip -br link show
```

### 12. `ip -s link show eth0`
**Описание:** Изучение статистики пакетов, таких как потерянные или ошибочные пакеты.

**Пример:**
```bash
ip -s link show eth0
```

### 13. `ethtool eth0`
**Описание:** Проверка свойств подключения, таких как согласованная скорость и режим полного дуплекса.

**Пример:**
```bash
ethtool eth0
```

---

# /etc/skel

:robot:

`/etc/skel` — это каталог в UNIX-подобных операционных системах, который используется для создания начальных (скелетных) файлов в домашнем каталоге нового пользователя. Когда создается новый пользователь, файлы и каталоги из `/etc/skel` копируются в его домашний каталог.

### Основные характеристики `/etc/skel`:

1. **Предназначение**:
   - Содержит шаблоны файлов, которые должны быть скопированы в домашний каталог каждого нового пользователя.
   - Обычно включает файлы конфигурации, такие как `.bashrc`, `.profile`, `.bash_profile`, `.bash_logout` и другие.

2. **Содержание**:
   - Файлы и каталоги, которые автоматически создаются для каждого нового пользователя.
   - Могут включать пользовательские настройки, скрипты и другие файлы, которые должны быть доступны пользователю с самого начала.

3. **Использование**:
   - Администраторы могут настраивать содержимое `/etc/skel` для всех новых пользователей, добавляя или изменяя файлы по мере необходимости.
   - Например, можно добавить общие настройки среды, скрипты начальной настройки, шаблоны документов и т.д.

### Пример содержимого `/etc/skel`:

```bash
/etc/skel
|-- .bash_logout
|-- .bashrc
|-- .profile
|-- .config/
|-- Documents/
|-- Downloads/
```

### Пример использования:

1. **Создание нового пользователя**:
   При создании нового пользователя с помощью команды `useradd` или `adduser`, файлы из `/etc/skel` копируются в домашний каталог нового пользователя.

   ```bash
   sudo useradd -m newuser
   ```

   В результате в домашнем каталоге `/home/newuser` появятся файлы и каталоги из `/etc/skel`.

2. **Настройка `/etc/skel`**:
   Администратор может добавить или изменить файлы в `/etc/skel` по своему усмотрению. Например:

   ```bash
   sudo cp /path/to/custom/.bashrc /etc/skel/.bashrc
   sudo mkdir /etc/skel/Templates
   sudo cp /path/to/template.doc /etc/skel/Templates/
   ```

Таким образом, `/etc/skel` предоставляет централизованный способ настройки начальной среды новых пользователей, что упрощает управление и стандартизацию пользовательских настроек в системе.

# Добавление сервтификата в Debian
/usr/local/share/ca-certificates/ Directory of local CA certificates (with .crt extension).
```
sudo cp trusted_root_ca.crt /usr/local/share/ca-certificates/
```
update-ca-certificates is a program that updates the directory /etc/ssl/certs to hold SSL certificates and generates ca-certificates.crt, a concatenated single-file list of certificates.
```
sudo update-ca-certificates -v
```

В Red Hat Linux (и других дистрибутивах, основанных на Red Hat, таких как CentOS и Fedora), управление пользователями и группами осуществляется с помощью различных команд. Вот основные команды, которые могут пригодиться для управления пользователями:

# Управление пользователями
## 1. **Создание пользователя**
   - `useradd <имя_пользователя>`  
     Создает нового пользователя в системе.

   - Пример: `useradd john`

   - Параметры:
     - `-m`: Создать домашний каталог пользователя.
     - `-d <путь_к_каталогу>`: Указать путь к домашнему каталогу.
     - `-s <shell>`: Указать оболочку (например, `/bin/bash`).
     - `-g <группа>`: Указать основную группу пользователя.
     - `-G <группы>`: Указать дополнительные группы.

## 2. **Задание пароля пользователя**
   - `passwd <имя_пользователя>`  
     Устанавливает или изменяет пароль пользователя.

   - Пример: `passwd john`

## 3. **Изменение информации о пользователе**
   - `usermod <опции> <имя_пользователя>`  
     Изменяет существующего пользователя.

   - Пример: `usermod -aG wheel john`  
     Добавляет пользователя "john" в группу "wheel".

   - Параметры:
     - `-aG <группа>`: Добавить пользователя в группу (без удаления из других групп).
     - `-l <новое_имя>`: Переименовать пользователя.
     - `-d <новый_домашний_каталог>`: Изменить домашний каталог.

## 4. **Удаление пользователя**
   - `userdel <имя_пользователя>`  
     Удаляет пользователя из системы.

   - Пример: `userdel john`

   - Параметры:
     - `-r`: Удалить домашний каталог и почту пользователя.

## 5. **Просмотр информации о пользователе**
   - `id <имя_пользователя>`  
     Показывает UID, GID и группы, к которым принадлежит пользователь.

   - Пример: `id john`

   - `finger <имя_пользователя>`  
     Выводит информацию о пользователе, такую как его полное имя, время входа, местонахождение и т.д.

   - Пример: `finger john`

## 6. **Управление группами**
   - `groupadd <имя_группы>`  
     Создает новую группу.

   - Пример: `groupadd developers`

   - `groupdel <имя_группы>`  
     Удаляет группу.

   - Пример: `groupdel developers`

   - `groupmod <опции> <имя_группы>`  
     Изменяет параметры существующей группы.

   - Пример: `groupmod -n devs developers`  
     Переименовывает группу "developers" в "devs".
     
   - Пример: `gpasswd -d user group`  
     Удалить пользователя "user" из группы "group".

## 7. **Просмотр списка пользователей и групп**
   - `cat /etc/passwd`  
     Отображает список всех пользователей системы.

   - `cat /etc/group`  
     Отображает список всех групп в системе.

## 8. **Добавление и удаление пользователей из групп**
   - `gpasswd -a <имя_пользователя> <имя_группы>`  
     Добавляет пользователя в группу.

   - Пример: `gpasswd -a john developers`

   - `gpasswd -d <имя_пользователя> <имя_группы>`  
     Удаляет пользователя из группы.

   - Пример: `gpasswd -d john developers`

## 9. **Блокировка и разблокировка пользователя**
   - `usermod -L <имя_пользователя>`  
     Блокирует учетную запись пользователя.

   - Пример: `usermod -L john`

   - `usermod -U <имя_пользователя>`  
     Разблокирует учетную запись пользователя.

   - Пример: `usermod -U john`

# openssl
## crl to pem
```bash
openssl crl -in ca.crl -inform DER -out crl.pem
```
## Запрос на выпуск сертификата сервера
## создать конфигурацию запроса на сертификат сервера
```bash
nano server_csr.cnf
```
```bash
[ req ]
default_bits       = 4096
default_md         = sha256
prompt             = no
default_keyfile    = SERVER.key
distinguished_name = req_distinguished_name
req_extensions     = req_ext

[ req_distinguished_name ]
C  = RU
ST = Moscow
CN = SERVER

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = SERVER
#DNS.2 =
#IP.1 = 
```
## генерация закрытого ключа
```bash
openssl genpkey -algorithm RSA -out SERVER.key -pkeyopt rsa_keygen_bits:4096
```
## генерация запроса на сертификат
```bash
openssl req -new -key SERVER.key -out SERVER.csr -config server_csr.cnf
```

## проверка запроса на выпуск сертификата
```bash
openssl req -in SERVER.csr -noout -text
```

# systemctl daemon-reload
Команда `systemctl daemon-reload` используется для того, чтобы перезагрузить конфигурацию `systemd`-демона. Она выполняется в следующих случаях:

1. **Обновление конфигурационных файлов**: Если вы внесли изменения в файлы юнитов (`.service`, `.socket`, `.timer` и т.д.), расположенные в каталогах `/etc/systemd/system/` или `/usr/lib/systemd/system/`, `systemd` не распознает эти изменения автоматически. Команда `systemctl daemon-reload` перезагружает конфигурацию, чтобы система учитывала внесенные изменения.

2. **Добавление новых юнитов**: Если вы добавили новые юниты или удалили старые, `systemd` также должен обновить свою конфигурацию. Это требуется, чтобы новые юниты были зарегистрированы и могли быть использованы.

3. **После выполнения обновлений**: В некоторых случаях, после обновления пакетов, связанных с `systemd`, рекомендуется выполнить `daemon-reload`, чтобы система использовала новые конфигурационные параметры.

Важно отметить, что перезагрузка конфигурации с помощью `systemctl daemon-reload` не прерывает и не перезапускает текущие службы. Это просто заставляет `systemd` заново считать конфигурационные файлы и обновить свою внутреннюю базу данных юнитов.

# sshd config
```bash
Match Group GROUP_NAME
    AllowUsers *@host1 *@host2 user1@10.10.10.10 user2@10.10.11.11
    X11Forwarding yes
    PermitEmptyPasswords no
    PasswordAuthentication no
    PubkeyAuthentication yes
    AllowTcpForwarding yes
```

# ssh jumphost
Configure .ssh/config
```bash
Host source
	HostName 1.1.1.1
	Port 22
	User admin
	IdentityFile ~/.ssh/privatebox
	StrictHostKeyChecking no
	UserKnownHostsFile /dev/null
	
Host destination
	HostName 2.2.2.2
        Port 22
	User admin
        StrictHostKeyChecking no
        UserKnownHostsFile /dev/null
	ProxyJump source
	IdentityFile ~/.ssh/privatebox
```
copy linux-amd64.tgz to /home/admin/ of destination host
```bash
scp -J admin@source linux-amd64.tgz destination:~
```

# User management

### Добавление, удаление и изменение пользователя
- `useradd <имя_пользователя>`: добавить нового пользователя
- `useradd -m <имя_пользователя>`: добавить нового пользователя с домашним каталогом
- `userdel -r <имя_пользователя>`: удалить пользователя и его домашний каталог
- `userdel <имя_пользователя>`: удалить пользователя без удаления домашнего каталога
- `useradd -a <имя_группы> <имя_пользователя>`: добавить нового пользователя с основной группой
- `usermod -m -d/путь/к/новому/каталогу <имя_пользователя>`: перенести домашний каталог пользователя
- `usermod -s /usr/bin/zsh <имя_пользователя>`: изменить оболочку для входа у пользователя
- `usermod -s /usr/sbin/nologin <имя_пользователя>`: запретить пользователю вход в систему
- `usermod -e ГГГГ-ММ-ДД <имя_пользователя>`: изменить дату окончания действия аккаунта
- `passwd -l <имя_пользователя>`: заблокировать пользователя, чтобы отключить вход (аналог `usermod -L`)
- `passwd -u <имя_пользователя>`: разблокировать пользователя для повторного включения входа (аналог `usermod -U`)

### Добавление, удаление и изменение группы
- `groupadd <имя_группы>`: создать новую группу
- `groupdel <имя_группы>`: удалить группу
- `usermod -aG <имя_группы> <имя_пользователя>`: добавить пользователя в указанную группу
- `gpasswd -d <имя_пользователя> <имя_группы>`: убрать пользователя из указанной группы
- `groupmod -n <новое_имя_группы> <старое_имя_группы>`: изменить имя группы

### Отображение информации о пользователях и группах
- `whoami`: показать имя текущего пользователя (аналог `echo $USER`)
- `id <имя_пользователя>`: показать UID, GID и группы, к которым принадлежит пользователь
- `id -gn <имя_пользователя>`: показать основную группу пользователя
- `groups <имя_пользователя>`: показать все группы (основные и вторичные), к которым принадлежит пользователь
- `getent group <имя_группы>`: показать всех пользователей, входящих в указанную группу
- `getent passwd`: показать все записи в базе данных паролей
- `getent group`: показать все записи в базе данных групп

# Переменные окружения Linux

Переменные окружения в Linux — это пары ключ-значение, которые определяются для текущей оболочки и её дочерних процессов. Они влияют на поведение процессов и позволяют настраивать параметры системы под конкретного пользователя. Ниже приведены основные переменные окружения с примерами их использования.

- **`DISPLAY`**: Идентификатор сервера отображения (чаще всего используется в графических окружениях).
  - Пример: `echo $DISPLAY` покажет текущий дисплей, например `:0`.

- **`EDITOR`**: Текстовый редактор по умолчанию, используемый различными инструментами (например, `crontab`, `visudo`).
  - Пример: `export EDITOR=nano` установит `nano` как редактор по умолчанию.

- **`HOME`**: Домашний каталог текущего пользователя.
  - Пример: `cd $HOME` переместит вас в домашний каталог пользователя.

- **`HOSTNAME`**: Имя хост-системы.
  - Пример: `echo $HOSTNAME` выведет имя вашего компьютера.

- **`HISTSIZE`**: Количество команд, которые нужно запомнить в истории команд.
  - Пример: `export HISTSIZE=1000` установит историю команд на 1000 записей.

- **`HISTFILE`**: Файл, в котором сохраняется история команд.
  - Пример: `echo $HISTFILE` покажет путь к файлу, в котором хранится история, обычно это `~/.bash_history`.

- **`JAVA_HOME`**: Путь к каталогу установки JDK или JRE.
  - Пример: `export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64` указывает на место установки JDK.

- **`LANG`**: Язык системы и настройки локали.
  - Пример: `export LANG=ru_RU.UTF-8` установит русский язык как основной для системы.

- **`LD_LIBRARY_PATH`**: Набор директорий для динамических общих библиотек.
  - Пример: `export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH` добавит каталог `/usr/local/lib` в путь поиска библиотек.

- **`LOGNAME`**: Имя пользователя, который изначально вошел в сеанс.
  - Пример: `echo $LOGNAME` покажет имя пользователя, под которым вы вошли в систему.

- **`OLDPWD`**: Предыдущий рабочий каталог.
  - Пример: `cd $OLDPWD` переместит вас в каталог, в котором вы были до текущего.

- **`PATH`**: Набор директорий, в которых оболочка ищет исполняемые файлы.
  - Пример: `echo $PATH` покажет текущий путь поиска, например, `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin`.

- **`PYTHONPATH`**: Набор директорий, которые Python ищет для модулей.
  - Пример: `export PYTHONPATH=/home/user/my_python_libs` добавит каталог в путь поиска модулей Python.

- **`PWD`**: Путь к каталогу, в котором находится пользователь в данный момент.
  - Пример: `echo $PWD` покажет текущий рабочий каталог.

- **`SHELL`**: Путь к оболочке текущего пользователя.
  - Пример: `echo $SHELL` покажет, какая оболочка используется, например `/bin/bash`.

- **`TERM`**: Тип терминала, эмулируемого в оболочке.
  - Пример: `echo $TERM` покажет тип терминала, например `xterm-256color`.

- **`UID`**: Числовой идентификатор текущего пользователя.
  - Пример: `echo $UID` покажет ваш UID, например `1000`.

- **`USER`**: Имя текущего пользователя.
  - Пример: `echo $USER` выведет ваше имя пользователя.

- **`XDG_SESSION_TYPE`**: Тип сеанса, в котором работает пользователь (например, `x11`, `wayland`).
  - Пример: `echo $XDG_SESSION_TYPE` покажет тип вашего текущего сеанса.

- **`XDG_CURRENT_DESKTOP`**: Название текущего окружения рабочего стола.
  - Пример: `echo $XDG_CURRENT_DESKTOP` покажет, какое окружение рабочего стола используется, например `GNOME` или `KDE`.

# strongSwan
Ниже приведена полная инструкция по настройке шифрованного туннеля IPsec между двумя хостами с использованием сильных алгоритмов шифрования. В этой инструкции мы будем использовать `strongSwan` для управления IPsec соединениями и настроим туннель между хостами с IP-адресами `192.168.10.10` и `192.168.123.20`.

### Шаг 1: Установка strongSwan

На обоих хостах (192.168.10.10 и 192.168.123.20) установите strongSwan.

#### Для Ubuntu/Debian:
```bash
sudo apt update
sudo apt install strongswan
```

#### Для CentOS/RHEL:
```bash
sudo yum install strongswan
```

### Шаг 2: Настройка конфигурации IPsec

Настройте конфигурационные файлы IPsec на обоих хостах.

#### Настройка на хосте 192.168.10.10

Редактируйте файл `/etc/ipsec.conf`:

```bash
sudo nano /etc/ipsec.conf
```

Замените содержимое на следующее:

```bash
config setup
    charondebug="ike 2, knl 2, cfg 2"

conn mytunnel
    left=192.168.10.10
    leftsubnet=192.168.10.0/24
    right=192.168.123.20
    rightsubnet=192.168.123.0/24
    ike=aes256gcm16-sha256-modp2048!
    esp=aes256gcm16-sha256!
    keyexchange=ikev2
    dpdaction=restart
    dpddelay=30s
    dpdtimeout=120s
    rekey=yes
    auto=start
```

Редактируйте файл `/etc/ipsec.secrets` для указания предварительно разделенного ключа (PSK):

```bash
sudo nano /etc/ipsec.secrets
```

Добавьте строку:

```bash
192.168.10.10 192.168.123.20 : PSK "myverystrongpassword"
```

#### Настройка на хосте 192.168.123.20

Повторите аналогичные шаги на втором хосте (192.168.123.20).

Редактируйте файл `/etc/ipsec.conf`:

```bash
sudo nano /etc/ipsec.conf
```

Замените содержимое на следующее:

```bash
config setup
    charondebug="ike 2, knl 2, cfg 2"

conn mytunnel
    left=192.168.123.20
    leftsubnet=192.168.123.0/24
    right=192.168.10.10
    rightsubnet=192.168.10.0/24
    ike=aes256gcm16-sha256-modp2048!
    esp=aes256gcm16-sha256!
    keyexchange=ikev2
    dpdaction=restart
    dpddelay=30s
    dpdtimeout=120s
    rekey=yes
    auto=start
```

Редактируйте файл `/etc/ipsec.secrets`:

```bash
sudo nano /etc/ipsec.secrets
```

Добавьте строку:

```bash
192.168.123.20 192.168.10.10 : PSK "myverystrongpassword"
```

### Шаг 3: Запуск службы IPsec

На обоих хостах перезапустите службу strongSwan для применения настроек:

```bash
sudo systemctl restart strongswan
```

### Шаг 4: Проверка статуса туннеля

Проверьте статус туннеля, чтобы убедиться, что он установлен и работает:

```bash
sudo ipsec statusall
```

Эта команда покажет информацию о текущих соединениях IPsec, а также о том, какие алгоритмы используются и какое состояние туннеля.

### Шаг 5: Тестирование соединения

После настройки и запуска туннеля протестируйте соединение между двумя хостами.

#### С хоста 192.168.10.10:

```bash
ping 192.168.123.20
```

#### С хоста 192.168.123.20:

```bash
ping 192.168.10.10
```

Если туннель работает корректно, пинги должны пройти, и пакеты будут передаваться через защищенный IPsec туннель.

### Шаг 6: Мониторинг и аудит

Для мониторинга трафика через туннель вы можете использовать `tcpdump` для проверки пакетов ESP:

```bash
sudo tcpdump -i eth0 esp
```

Эта команда покажет трафик, проходящий через туннель, что подтвердит, что данные передаются зашифрованными.

### Пояснение используемых параметров

- **`ike=aes256gcm16-sha256-modp2048!`**: Определяет алгоритмы для фазы 1 (IKE):
  - `aes256gcm16`: Использует AES-GCM с длиной ключа 256 бит и 16-битной аутентификацией.
  - `sha256`: Алгоритм хэширования SHA-256 для обеспечения целостности данных.
  - `modp2048`: 2048-битная группа Диффи-Хеллмана для обмена ключами.

- **`esp=aes256gcm16-sha256!`**: Определяет алгоритмы для фазы 2 (ESP):
  - `aes256gcm16`: Шифрование с использованием AES-GCM.
  - `sha256`: Хэширование с использованием SHA-256.

- **`dpdaction=restart`**: Включает обнаружение мертвых пиров (DPD), что позволяет автоматически перезапускать соединение в случае его разрыва.

- **`rekey=yes`**: Включает автоматическое пересогласование ключей через определенные интервалы времени, что повышает безопасность.

# IP

### Примеры команд `ip` в Linux

#### Управление IP-адресами (`ip addr`)
- **`ip addr show`**: отображает все IP-адреса.
  - Пример: `ip addr show` — показывает все IP-адреса на всех интерфейсах.

- **`ip addr show dev eth0`**: показывает IP-адреса на интерфейсе `eth0`.
  - Пример: `ip addr show dev eth0` — отображает IP-адреса, назначенные интерфейсу `eth0`.

- **`ip addr add 1.1.1.1/24 dev eth0`**: добавляет IP-адрес.
  - Пример: `ip addr add 1.1.1.1/24 dev eth0` — добавляет IP-адрес `1.1.1.1` с маской `24` на интерфейс `eth0`.

- **`ip addr del 1.1.1.1/24 dev eth0`**: удаляет IP-адрес.
  - Пример: `ip addr del 1.1.1.1/24 dev eth0` — удаляет IP-адрес `1.1.1.1` с интерфейса `eth0`.

- **`ip addr flush dev eth0`**: удаляет все IP-адреса с интерфейса.
  - Пример: `ip addr flush dev eth0` — очищает все IP-адреса, назначенные интерфейсу `eth0`.

#### Управление сетевыми интерфейсами (`ip link`)
- **`ip link show`**: отображает все сетевые интерфейсы.
  - Пример: `ip link show` — показывает информацию обо всех сетевых интерфейсах.

- **`ip link show eth0`**: отображает детали интерфейса `eth0`.
  - Пример: `ip link show eth0` — отображает информацию о сетевом интерфейсе `eth0`.

- **`ip link set eth0 up|down`**: активирует или деактивирует интерфейс.
  - Пример: `ip link set eth0 up` — включает интерфейс `eth0`.
  - Пример: `ip link set eth0 down` — выключает интерфейс `eth0`.

- **`ip link set eth0 mtu 9000`**: устанавливает MTU для интерфейса.
  - Пример: `ip link set eth0 mtu 9000` — устанавливает MTU 9000 байт на интерфейсе `eth0`.

- **`ip link set eth0 promisc on`**: включает промискуитетный режим.
  - Пример: `ip link set eth0 promisc on` — включает промискуитетный режим на интерфейсе `eth0`.

- **`ip link set eth0`**: показывает статистику интерфейса `eth0`.
  - Пример: `ip link set eth0` — показывает текущие показатели и статус интерфейса `eth0`.

- **`ip link set eth0 addr 11:22:33:44:55:66`**: изменяет MAC-адрес.
  - Пример: `ip link set eth0 addr 11:22:33:44:55:66` — назначает новый MAC-адрес интерфейсу `eth0`.

#### Управление маршрутами (`ip route`)
- **`ip route`**: отображает все маршруты.
  - Пример: `ip route` — показывает таблицу маршрутизации для системы.

- **`ip route show default`**: показывает маршрут по умолчанию.
  - Пример: `ip route show default` — показывает текущий маршрут по умолчанию.

- **`ip route flush dev eth0`**: удаляет все маршруты для `eth0`.
  - Пример: `ip route flush dev eth0` — очищает все маршруты, назначенные интерфейсу `eth0`.

- **`ip route get 1.1.1.1`**: показывает маршрут к `1.1.1.1`.
  - Пример: `ip route get 1.1.1.1` — отображает маршрут до IP-адреса `1.1.1.1`.

- **`ip route show 1.1.1.0/24`**: показывает маршрут для подсети `1.1.1.0/24`.
  - Пример: `ip route show 1.1.1.0/24` — отображает маршрут до подсети `1.1.1.0/24`.

- **`ip route add 1.1.1.0/24 dev eth0`**: добавляет маршрут для подсети `1.1.1.0/24`.
  - Пример: `ip route add 1.1.1.0/24 dev eth0` — добавляет маршрут для подсети через интерфейс `eth0`.

- **`ip route add default via 192.168.0.1 dev eth0`**: добавляет маршрут по умолчанию.
  - Пример: `ip route add default via 192.168.0.1 dev eth0` — устанавливает маршрут по умолчанию через `192.168.0.1` для интерфейса `eth0`.

- **`ip route add/del 1.1.1.0/24 via 192.168.0.1`**: добавляет/удаляет маршрут через следующий хоп.
  - Пример: `ip route add 1.1.1.0/24 via 192.168.0.1` — добавляет маршрут до подсети `1.1.1.0/24` через `192.168.0.1`.

- **`ip route replace 1.1.1.0/24 via 192.168.1.1 dev eth0`**: заменяет маршрут.
  - Пример: `ip route replace 1.1.1.0/24 via 192.168.1.1 dev eth0` — заменяет существующий маршрут до подсети `1.1.1.0/24` новым маршрутом через `192.168.1.1`.

- **`ip route add 1.1.1.0/24 via 192.168.1.1 dev eth0 metric 100`**: добавляет маршрут с указанным метриком.
  - Пример: `ip route add 1.1.1.0/24 via 192.168.1.1 dev eth0 metric 100` — добавляет маршрут до подсети с метрикой 100.

#### Управление ARP-соседями (`ip neigh`)
- **`ip neigh show`**: отображает все записи ARP-таблицы.
  - Пример: `ip neigh show` — показывает текущую таблицу ARP для системы.

- **`ip neigh show dev eth0`**: отображает ARP-соседей для `eth0`.
  - Пример: `ip neigh show dev eth0` — показывает ARP-соседей для интерфейса `eth0`.

- **`ip neigh del 192.168.0.2`**: удаляет запись ARP.
  - Пример: `ip neigh del 192.168.0.2` — удаляет запись ARP для IP-адреса `192.168.0.2`.

- **`ip neigh add 192.168.0.2 lladdr <mac-addr> dev eth0 nud permanent`**: добавляет статическую запись ARP.
  - Пример: `ip neigh add 192.168.0.2 lladdr 00:11:22:33:44:55 dev eth0 nud permanent` — добавляет статическую ARP-запись для IP-адреса `192.168.0.2`.

- **`ip neigh change 192.168.0.2 lladdr <mac-addr> dev eth0`**: изменяет существующую запись ARP.
  - Пример: `ip neigh change 192.168.0.2 lladdr 00:11:22:33:44:55 dev eth0` — изменяет существующую запись ARP.

- **`ip neigh flush to 192.168.0.0/24`**: очищает ARP для определенной подсети.
  - Пример: `ip neigh flush to 192.168.0.0/24` — удаляет все ARP-записи для подсети `192.168.0.0/24`.

#### Управление туннелями (`ip tunnel`)
- **`ip tunnel show`**: отображает все настроенные туннели.
  - Пример: `ip tunnel show` — показывает текущие туннели, настроенные в системе.

- **`ip tunnel add gre1 mode gre remote 10.0.0.2 local 10.0.0.1 ttl 255`**: создает GRE туннель.
  - Пример: `ip tunnel add gre1 mode gre remote 10.0.0.2 local 10.0.0.1 ttl 255` — создает туннель GRE между IP-адресами `10.0.0.1` и `10.0.0.2`.

# grep

### Примеры команд `grep` в Linux

- **`grep "example" my.txt`**: искать "example" в файле `my.txt`.
  - Пример: `grep "example" my.txt` — находит строки, содержащие слово "example" в файле `my.txt`.

- **`grep "example" *.txt`**: искать "example" во всех `.txt` файлах.
  - Пример: `grep "example" *.txt` — находит строки с "example" во всех текстовых файлах в текущем каталоге.

- **`grep -i "example" my.txt`**: искать "example", игнорируя регистр букв.
  - Пример: `grep -i "example" my.txt` — находит "example" или "Example" независимо от регистра.

- **`grep -c "example" my.txt`**: подсчитать количество строк, содержащих "example".
  - Пример: `grep -c "example" my.txt` — возвращает количество строк в файле `my.txt`, содержащих "example".

- **`grep -n "example" my.txt`**: показать номера строк вместе с найденными строками.
  - Пример: `grep -n "example" my.txt` — показывает номера строк, в которых найдено "example".

- **`grep -r "example" .`**: искать "example" рекурсивно во всех файлах в текущем каталоге.
  - Пример: `grep -r "example" .` — рекурсивно ищет "example" во всех файлах и подкаталогах.

- **`grep -v "example" my.txt`**: показать строки, которые не содержат "example".
  - Пример: `grep -v "example" my.txt` — выводит строки, не содержащие "example".

- **`grep -w "example" my.txt`**: искать строки, содержащие "example" как отдельное слово.
  - Пример: `grep -w "example" my.txt` — находит строки, где "example" стоит как отдельное слово.

- **`grep -e "key1" -e "key2" my.txt`**: искать строки, содержащие "key1" или "key2".
  - Пример: `grep -e "key1" -e "key2" my.txt` — находит строки, содержащие либо "key1", либо "key2".

- **`grep -v -e "key1" -e "key2" my.txt`**: показать строки, которые не содержат ни "key1", ни "key2".
  - Пример: `grep -v -e "key1" -e "key2" my.txt` — показывает строки, которые не содержат "key1" и "key2".

- **`grep "key1\|key2" my.txt`**: показать строки, содержащие как "key1", так и "key2".
  - Пример: `grep "key1\|key2" my.txt` — находит строки, где есть "key1" или "key2".

- **`grep -E "error|warning" app.log`**: использовать расширенное регулярное выражение для поиска.
  - Пример: `grep -E "error|warning" app.log` — находит строки, содержащие "error" или "warning".

- **`grep -E "^[a-zA-Z]" my.txt`**: еще один пример с расширенными регулярными выражениями.
  - Пример: `grep -E "^[a-zA-Z]" my.txt` — находит строки, начинающиеся с буквы.

- **`grep -m3 "keyword" my.txt`**: ограничить вывод `grep` определенным количеством строк.
  - Пример: `grep -m3 "keyword" my.txt` — выводит только первые три совпадения.

- **`grep -A2 -B2 "example" my.txt`**: показать 2 строки до и после совпадения.
  - Пример: `grep -A2 -B2 "example" my.txt` — показывает 2 строки до и после найденного "example".

- **`grep -C3 "error" server.log`**: показать 3 строки до и после совпадения.
  - Пример: `grep -C3 "error" server.log` — показывает 3 строки до и после строки с "error".

- **`grep -x "spoofing" my.txt`**: показать строки, точно совпадающие с "spoofing".
  - Пример: `grep -x "spoofing" my.txt` — находит строки, которые содержат только "spoofing".

- **`grep -l "example" *`**: показать имена файлов, в которых есть совпадение.
  - Пример: `grep -l "example" *` — показывает список файлов, в которых найдено "example".

- **`grep "^hello" my.txt`**: показать строки, начинающиеся с "hello".
  - Пример: `grep "^hello" my.txt` — выводит строки, начинающиеся с "hello".

- **`grep "done$" my.txt`**: показать строки, заканчивающиеся на "done".
  - Пример: `grep "done$" my.txt` — выводит строки, заканчивающиеся на "done".

- **`grep -o "begin.*end" my.txt`**: показать только совпадающие строки.
  - Пример: `grep -o "begin.*end" my.txt` — выводит только ту часть строки, которая совпадает с шаблоном.

- **`grep --color "example" my.txt`**: выделить цветом совпадения в выводе `grep`.
  - Пример: `grep --color "example" my.txt` — выводит совпадения с "example", выделяя их цветом.

- **`grep "[0-9]" my.txt`**: показать строки, содержащие цифры.
  - Пример: `grep "[0-9]" my.txt` — находит строки, содержащие хотя бы одну цифру.

- **`grep -a "string" my.bin`**: искать строку в бинарном файле.
  - Пример: `grep -a "string" my.bin` — ищет текст "string" в бинарном файле `my.bin`.

# cp
### Примеры команд `cp` в Linux

- **`cp <src-file> <dst-file>`**: копировать один исходный файл в файл назначения.
  - Пример: `cp file1.txt file2.txt` — копирует содержимое файла `file1.txt` в файл `file2.txt`.

- **`cp file1 file2 file3 <dst-dir>`**: копировать несколько файлов в каталог назначения.
  - Пример: `cp file1.txt file2.txt dir/` — копирует файлы `file1.txt` и `file2.txt` в каталог `dir`.

- **`cp -r <src-dir> <dst-dir>`**: копировать дерево каталогов рекурсивно.
  - Пример: `cp -r dir1/ dir2/` — рекурсивно копирует содержимое каталога `dir1` в `dir2`.

- **`cp -v <src> <dst>`**: отображать имена файлов по мере их копирования.
  - Пример: `cp -v file1.txt dir/` — копирует файл с отображением процесса копирования.

- **`cp <src-dir>/*.{jpg,png} <dst-dir>`**: копировать все файлы `.jpg` и `.png`.
  - Пример: `cp dir1/*.{jpg,png} dir2/` — копирует все `.jpg` и `.png` файлы из `dir1` в `dir2`.

- **`cp -n <src> <dst>`**: не перезаписывать существующие файлы назначения.
  - Пример: `cp -n file1.txt dir/` — копирует файл только если он отсутствует в каталоге назначения.

- **`cp -f <src> <dst>`**: перезаписывать файлы в каталоге назначения без запроса.
  - Пример: `cp -f file1.txt dir/` — принудительно перезаписывает существующие файлы.

- **`cp -u <src> <dst>`**: копировать только если исходный файл новее или отсутствует файл назначения.
  - Пример: `cp -u file1.txt dir/` — копирует файл только если он новее или отсутствует в каталоге назначения.

- **`cp --preserve=mode,ownership <src> <dst>`**: копировать, сохраняя режим и владельца.
  - Пример: `cp --preserve=mode,ownership file1.txt dir/` — сохраняет права доступа и владельца при копировании.

- **`cp -dR <src> <dst>`**: копировать, сохраняя символические ссылки.
  - Пример: `cp -dR dir1/ dir2/` — сохраняет символические ссылки при рекурсивном копировании.

- **`cp -p <src> <dst>`**: то же, что и `--preserve=mode,ownership,timestamps`.
  - Пример: `cp -p file1.txt dir/` — сохраняет все атрибуты файла (права, владельца, временные метки) при копировании.

- **`cp -a <src> <dst>`**: сохранять все атрибуты файлов и символические ссылки.
  - Пример: `cp -a dir1/ dir2/` — делает точную копию каталога с сохранением всех атрибутов.

- **`cp -r <src-dir>/*name <dst-dir>`**: копировать файлы и каталоги с определенным именем.
  - Пример: `cp -r dir1/*name dir2/` — копирует все файлы и каталоги, содержащие "name" в имени.

- **`cp -P <src-dir> <dst-dir>`**: копировать без следования за символическими ссылками.
  - Пример: `cp -P dir1/ dir2/` — копирует содержимое каталога, не следуя за символическими ссылками.

- **`cp --attributes-only <src> <dst>`**: копировать только атрибуты файлов, не контент.
  - Пример: `cp --attributes-only file1.txt file2.txt` — копирует только атрибуты файла (права доступа, владельца).

- **`cp -rl <src> <dst>`**: создавать жесткие ссылки вместо копирования файлов.
  - Пример: `cp -rl dir1/ dir2/` — создает жесткие ссылки на файлы из `dir1` в `dir2`.

- **`cp -rs <src> <dst>`**: создавать символические ссылки вместо копирования файлов.
  - Пример: `cp -rs dir1/ dir2/` — создает символические ссылки на файлы из `dir1` в `dir2`.

- **`cp --parents dir1/dir2/file <dst-dir>`**: копировать с сохранением структуры каталогов.
  - Пример: `cp --parents dir1/dir2/file dir3/` — копирует файл с сохранением структуры каталогов.

- **`find . -type f -name "*.txt" -exec cp {} <dst-dir> \;`**: копировать все текстовые файлы в `dst-dir`.
  - Пример: `find . -type f -name "*.txt" -exec cp {} dir/ \;` — копирует все файлы `.txt` в каталог `dir`.

- **`find . -type f -mtime -7 -exec cp {} <dst-dir> \;`**: копировать файлы, измененные за последние 7 дней.
  - Пример: `find . -type f -mtime -7 -exec cp {} dir/ \;` — копирует все файлы, измененные в последние 7 дней, в каталог `dir`.

- **`find . -type f -name "*.log" -print0 | xargs -0 cp -t <dst-dir>`**: копировать множество файлов.
  - Пример: `find . -type f -name "*.log" -print0 | xargs -0 cp -t dir/` — копирует все `.log` файлы в каталог `dir`.

- **`rsync -a --progress <src-dir> <dst-dir>`**: показать прогресс при копировании файлов.
  - Пример: `rsync -a --progress dir1/ dir2/` — синхронизирует каталоги с отображением прогресса.

# lsof
### Примеры команд `lsof` в Linux

#### Список открытых файлов (List Open Files)

- **`lsof`**: вывести список всех файлов, открытых любым процессом.
  - Пример: `lsof` — показывает все открытые файлы и процессы, которые их открыли.

- **`lsof -p 1000`**: вывести список файлов, открытых процессом с PID 1000.
  - Пример: `lsof -p 1000` — показывает файлы, открытые процессом с идентификатором 1000.

- **`lsof -P ^1000`**: вывести список файлов, открытых любым другим процессом, кроме процесса с PID 1000.
  - Пример: `lsof -P ^1000` — показывает файлы, открытые процессами, кроме процесса с идентификатором 1000.

- **`lsof -u <username>`**: вывести список файлов, открытых процессами, принадлежащими указанному пользователю.
  - Пример: `lsof -u dan` — показывает файлы, открытые процессами, принадлежащими пользователю `dan`.

- **`lsof -u^root`**: вывести список файлов, открытых всеми пользователями, кроме root.
  - Пример: `lsof -u^root` — показывает файлы, открытые пользователями, кроме root.

- **`lsof <directory>`**: показать, какие процессы используют указанный каталог.
  - Пример: `lsof /var/log` — показывает процессы, работающие с файлами в каталоге `/var/log`.

- **`lsof <filename>`**: вывести список всех процессов, которые открыли указанный файл.
  - Пример: `lsof /var/log/syslog` — показывает процессы, открывшие файл `/var/log/syslog`.

- **`lsof +D /tmp`**: вывести список всех файлов, открытых под `/tmp`.
  - Пример: `lsof +D /tmp` — показывает все открытые файлы в каталоге `/tmp`.

- **`lsof +L1`**: вывести список удаленных, но все еще открытых файлов, удерживаемых запущенными процессами.
  - Пример: `lsof +L1` — показывает файлы, которые были удалены из файловой системы, но все еще удерживаются открытыми процессами.

- **`lsof -c <command>`**: вывести список файлов, открытых процессами, исполняющими указанную команду.
  - Пример: `lsof -c nginx` — показывает файлы, открытые процессами `nginx`.

- **`lsof -d mem`**: вывести список всех файлов, отображаемых в памяти (memory-mapped files).
  - Пример: `lsof -d mem` — показывает все файлы, отображаемые в память.

#### Сетевые подключения и сокеты (List Network Connections and Sockets)

- **`lsof -i`**: вывести список всех открытых сетевых соединений.
  - Пример: `lsof -i` — показывает все активные сетевые соединения.

- **`lsof -i :80`**: вывести список открытых TCP/UDP соединений на порту 80.
  - Пример: `lsof -i :80` — показывает процессы, работающие с портом 80 (например, HTTP).

- **`lsof -i tcp:1-1024`**: вывести список открытых TCP соединений в указанном диапазоне портов.
  - Пример: `lsof -i tcp:1-1024` — показывает TCP соединения на портах от 1 до 1024.

- **`lsof -i -n`**: вывести список сетевых соединений без обратного поиска DNS.
  - Пример: `lsof -i -n` — показывает сетевые соединения без попытки разрешения IP-адресов в DNS-имена.

- **`lsof -i -n -P`**: вывести список сетевых соединений с номерами портов вместо имен портов.
  - Пример: `lsof -i -n -P` — показывает сетевые соединения с указанием номеров портов, а не имен служб.

- **`lsof -i6`**: вывести список открытых IPv6 сетевых соединений.
  - Пример: `lsof -i6` — показывает активные IPv6 соединения.

#### Прочие команды (Other Usages)

- **`lsof -U`**: вывести список всех открытых сокетов Unix-доменов.
  - Пример: `lsof -U` — показывает все открытые Unix-сокеты.

- **`lsof /dev/tty1`**: вывести команды/процессы, связанные с `/dev/tty1`.
  - Пример: `lsof /dev/tty1` — показывает процессы, работающие с терминалом `/dev/tty1`.

- **`kill -9 $(lsof -t -u <username>)`**: убить все активности определенного пользователя.
  - Пример: `kill -9 $(lsof -t -u dan)` — завершает все процессы, принадлежащие пользователю `dan`.

# sed
### Примеры команд `sed` в Linux

- **`sed 's/old/new/' my.txt`**: заменить первое вхождение "old" на "new" в каждой строке.
  - Пример: `sed 's/old/new/' my.txt` — заменяет первое вхождение "old" на "new" в каждой строке файла `my.txt`.

- **`sed 's/old/new/g' my.txt`**: заменить все вхождения "old" на "new" в каждой строке.
  - Пример: `sed 's/old/new/g' my.txt` — заменяет все вхождения "old" на "new" в каждой строке файла `my.txt`.

- **`sed 's/old/new/gi' my.txt`**: игнорировать регистр при поиске ключевого слова.
  - Пример: `sed 's/old/new/gi' my.txt` — заменяет все вхождения "old" на "new", игнорируя регистр.

- **`sed 's/old/new/3' my.txt`**: заменить 3-е вхождение "old" на "new" в каждой строке.
  - Пример: `sed 's/old/new/3' my.txt` — заменяет только третье вхождение "old" на "new" в каждой строке файла `my.txt`.

- **`sed '3,8s/old/new/g' my.txt`**: ограничить замену конкретными строками (с 3-й по 8-ю).
  - Пример: `sed '3,8s/old/new/g' my.txt` — заменяет "old" на "new" только в строках с 3 по 8 в файле `my.txt`.

- **`sed '/pattern/s/old/new/g' my.txt`**: заменить только в тех строках, которые соответствуют шаблону.
  - Пример: `sed '/pattern/s/old/new/g' my.txt` — заменяет "old" на "new" только в строках, содержащих "pattern".

- **`sed '/pattern/i\text line' my.txt`**: вставить строку перед совпадением с шаблоном.
  - Пример: `sed '/pattern/i\text line' my.txt` — добавляет строку "text line" перед строкой, содержащей "pattern".

- **`sed '/pattern/a\text line' my.txt`**: вставить строку после совпадения с шаблоном.
  - Пример: `sed '/pattern/a\text line' my.txt` — добавляет строку "text line" после строки, содержащей "pattern".

- **`sed -n '/pattern/p' my.txt`**: вывести только строки, соответствующие шаблону.
  - Пример: `sed -n '/pattern/p' my.txt` — выводит только те строки, которые содержат "pattern".

- **`sed -n '5,10p' my.txt`**: вывести диапазон строк (с 5-й по 10-ю).
  - Пример: `sed -n '5,10p' my.txt` — выводит строки с 5 по 10.

- **`sed -n -e '3,5p' -e '10,15p' my.txt`**: вывести несколько диапазонов строк.
  - Пример: `sed -n -e '3,5p' -e '10,15p' my.txt` — выводит строки с 3 по 5 и с 10 по 15.

- **`sed -i 's/old/new/g' my.txt`**: редактировать файл на месте.
  - Пример: `sed -i 's/old/new/g' my.txt` — заменяет "old" на "new" в файле `my.txt` и сохраняет изменения.

- **`sed -i 's/\r//' my.txt`**: удалить символы ^M (символ новой строки DOS) в каждой строке.
  - Пример: `sed -i 's/\r//' my.txt` — удаляет символы возврата каретки (CR) в файле `my.txt`.

- **`sed -i.orig 's/old/new/gi' my.txt`**: сохранить обновленный файл как `my.txt.orig`.
  - Пример: `sed -i.orig 's/old/new/gi' my.txt` — сохраняет оригинал файла как `my.txt.orig` перед заменой "old" на "new".

- **`sed -i 's/old/new/g;s/this/that/g' my.txt`**: выполнить несколько замен.
  - Пример: `sed -i 's/old/new/g;s/this/that/g' my.txt` — заменяет "old" на "new" и "this" на "that" в файле `my.txt`.

- **`sed '5c\this is a new line' my.txt`**: изменить конкретную строку (5-я строка).
  - Пример: `sed '5c\this is a new line' my.txt` — заменяет содержимое 5-й строки на "this is a new line".

- **`sed '/pattern/c\this is a new line' my.txt`**: изменить несколько строк, соответствующих шаблону.
  - Пример: `sed '/pattern/c\this is a new line' my.txt` — заменяет строки, содержащие "pattern", на "this is a new line".

- **`sed = my.txt | sed 'N;s/\n/ /'`**: добавить номер строки к каждой строке.
  - Пример: `sed = my.txt | sed 'N;s/\n/ /'` — нумерует строки в файле `my.txt`.

- **`sed 's/.*/\U&/' my.txt`**: преобразовать текст в каждой строке в верхний регистр.
  - Пример: `sed 's/.*/\U&/' my.txt` — делает все буквы в файле `my.txt` заглавными.

- **`sed -r 's/(foo|bar)/new/g' my.txt`**: заменить с использованием расширенного регулярного выражения.
  - Пример: `sed -r 's/(foo|bar)/new/g' my.txt` — заменяет "foo" или "bar" на "new".

- **`sed '/pattern/d' my.txt`**: удалить строки, соответствующие шаблону.
  - Пример: `sed '/pattern/d' my.txt` — удаляет строки, содержащие "pattern".

- **`sed '5d' my.txt`**: удалить определенную строку по номеру (например, 5-ю).
  - Пример: `sed '5d' my.txt` — удаляет 5-ю строку в файле `my.txt`.

- **`sed '2,5d' my.txt`**: удалить диапазон строк (например, с 2-й по 5-ю).
  - Пример: `sed '2,5d' my.txt` — удаляет строки с 2-й по 5-ю в файле `my.txt`.

# find
### Примеры команд `find` в Linux

- **`find . -name "my.txt"`**: найти все файлы с именем "my.txt".
  - Пример: `find . -name "my.txt"` — ищет файл с именем "my.txt" в текущем каталоге и всех подкаталогах.

- **`find . -type d -name "mydir"`**: найти все директории с именем "mydir".
  - Пример: `find . -type d -name "mydir"` — ищет директории с именем "mydir".

- **`find . -type f -name "*.jpg"`**: найти все файлы с расширением ".jpg".
  - Пример: `find . -type f -name "*.jpg"` — ищет все файлы с расширением ".jpg".

- **`find . -type f -size +100M`**: найти все файлы размером больше 100 МБ.
  - Пример: `find . -type f -size +100M` — ищет все файлы, размер которых превышает 100 мегабайт.

- **`find . -type f -size +100M -size -500M`**: найти файлы в определенном диапазоне размеров.
  - Пример: `find . -type f -size +100M -size -500M` — ищет файлы размером от 100 до 500 мегабайт.

- **`find . -type f -mtime -1`**: найти все файлы, измененные за последние 24 часа.
  - Пример: `find . -type f -mtime -1` — находит все файлы, измененные в течение последних суток.

- **`find . -mtime -7 -mtime +1`**: найти файлы, измененные между вчера и неделей назад.
  - Пример: `find . -mtime -7 -mtime +1` — ищет файлы, измененные между 1 и 7 днями назад.

- **`find . -type f -name "*.tmp" -delete`**: найти и удалить все файлы с расширением ".tmp".
  - Пример: `find . -type f -name "*.tmp" -delete` — находит и удаляет все файлы с расширением ".tmp".

- **`find . -type f -perm 0777`**: найти все файлы с правами доступа 777.
  - Пример: `find . -type f -perm 0777` — находит файлы с полными правами на чтение, запись и выполнение для всех пользователей.

- **`find . -type f -perm +u+x`**: найти все файлы, выполняемые пользователем.
  - Пример: `find . -type f -perm +u+x` — находит все файлы, у которых установлены права на выполнение для владельца.

- **`find . -type f -name "*.txt" -exec cat {} \;`**: найти и вывести содержимое всех файлов ".txt".
  - Пример: `find . -type f -name "*.txt" -exec cat {} \;` — выводит содержимое всех текстовых файлов.

- **`find . -type f -amin -60`**: найти все файлы, к которым обращались в последний час.
  - Пример: `find . -type f -amin -60` — находит файлы, доступ к которым осуществлялся в последние 60 минут.

- **`find . -type f -user dan`**: найти все файлы, принадлежащие пользователю "dan".
  - Пример: `find . -type f -user dan` — находит все файлы, владельцем которых является пользователь "dan".

- **`find . -type f -ctime -2`**: найти файлы, созданные в последние 2 дня.
  - Пример: `find . -type f -ctime -2` — находит файлы, созданные в течение последних двух дней.

- **`find . -maxdepth 1 -name "my.txt"`**: искать только в текущем каталоге.
  - Пример: `find . -maxdepth 1 -name "my.txt"` — ищет файл "my.txt" только в текущем каталоге, не заходя в подкаталоги.

- **`find . -type f -name "*.txt" | xargs chmod 644`**: изменить права доступа всех файлов ".txt" на 644.
  - Пример: `find . -type f -name "*.txt" | xargs chmod 644` — изменяет права доступа всех текстовых файлов на "чтение и запись для владельца, только чтение для остальных".

- **`find . -type f -name "*.jpg" | xargs tar -cf img.tgz`**: архивировать все файлы с расширением ".jpg".
  - Пример: `find . -type f -name "*.jpg" | xargs tar -cf img.tgz` — создает архив "img.tgz", включающий все файлы ".jpg".

- **`find . -type f -name "*.png" | xargs -I {} mv {} /tmp`**: переместить все файлы ".png" в папку "/tmp".
  - Пример: `find . -type f -name "*.png" | xargs -I {} mv {} /tmp` — перемещает все файлы с расширением ".png" в каталог "/tmp".

- **`find . -type f -name "*.txt" | xargs grep "Hello"`**: искать "Hello" во всех файлах ".txt".
  - Пример: `find . -type f -name "*.txt" | xargs grep "Hello"` — ищет слово "Hello" во всех текстовых файлах.

- **`find . -xtype l -delete`**: найти и удалить сломанные символические ссылки.
  - Пример: `find . -xtype l -delete` — находит и удаляет все битые символические ссылки.

- **`find . -type d -empty -delete`**: найти и удалить все пустые директории.
  - Пример: `find . -type d -empty -delete` — находит и удаляет все пустые каталоги.

- **`find . -newermt "2024-01-01" ! -newermt "2024-03-15"`**: использовать диапазон дат для поиска файлов.
  - Пример: `find . -newermt "2024-01-01" ! -newermt "2024-03-15"` — ищет файлы, измененные между 1 января 2024 года и 15 марта 2024 года.

# systemd
### Управление службами (Manage Services)

- **`systemctl status <имя-сервиса>`**: проверить статус указанной службы.
  - Пример: `systemctl status nginx` — отображает статус службы Nginx.

- **`systemctl [start|stop|restart] <имя-сервиса>`**: запустить/остановить/перезапустить указанную службу.
  - Пример: `systemctl start nginx` — запускает службу Nginx.
  - Пример: `systemctl stop nginx` — останавливает службу Nginx.
  - Пример: `systemctl restart nginx` — перезапускает службу Nginx.

- **`systemctl [enable|disable] <имя-сервиса>`**: включить или отключить автозапуск службы при загрузке системы.
  - Пример: `systemctl enable nginx` — включает автозапуск службы Nginx при загрузке.
  - Пример: `systemctl disable nginx` — отключает автозапуск службы Nginx при загрузке.

- **`systemctl reload <имя-сервиса>`**: перезагрузить конфигурацию службы без перезапуска самой службы.
  - Пример: `systemctl reload nginx` — перезагружает конфигурацию службы Nginx.

- **`systemctl daemon-reload`**: перезагрузить все конфигурационные файлы systemd.
  - Пример: `systemctl daemon-reload` — перезагружает все конфигурационные файлы systemd, если они были изменены.

### Просмотр служб (View Services)

- **`systemctl list-units`**: вывести список всех текущих активных служб.
  - Пример: `systemctl list-units` — показывает список всех активных служб.

- **`systemctl list-units --type=service --all`**: вывести список всех доступных служб.
  - Пример: `systemctl list-units --type=service --all` — отображает все доступные службы, включая неактивные.

- **`systemctl list-units --type=mount`**: вывести список всех смонтированных файловых систем.
  - Пример: `systemctl list-units --type=mount` — показывает список всех смонтированных файловых систем.

- **`systemctl --failed`**: вывести список всех служб, завершившихся с ошибками.
  - Пример: `systemctl --failed` — отображает список всех служб, которые завершились с ошибкой.

- **`systemctl list-units --state=inactive`**: вывести список всех служб с указанным состоянием (например, неактивные).
  - Пример: `systemctl list-units --state=inactive` — показывает все неактивные службы.

- **`systemctl list-units "*ssh*"`**: вывести список служб по шаблону (например, все службы, содержащие `ssh`).
  - Пример: `systemctl list-units "*ssh*"` — показывает все службы, содержащие `ssh` в названии.

- **`systemctl show <имя-сервиса>`**: показать подробные свойства указанной службы.
  - Пример: `systemctl show nginx` — отображает подробную информацию о службе Nginx.

- **`systemctl list-dependencies <имя-сервиса>`**: вывести зависимости указанной службы.
  - Пример: `systemctl list-dependencies nginx` — показывает зависимости службы Nginx.

### Проверка производительности загрузки (Inspect Boot Performance)

- **`systemd-analyze time`**: показать время загрузки системы.
  - Пример: `systemd-analyze time` — отображает время загрузки системы и её компонентов.

- **`systemd-analyze blame`**: вывести отсортированный список служб по времени задержки при запуске.
  - Пример: `systemd-analyze blame` — показывает службы, которые дольше всего загружались при старте системы.

- **`systemd-analyze critical-chain`**: показать дерево зависимостей критически важных служб.
  - Пример: `systemd-analyze critical-chain` — отображает цепочку критически важных служб и их зависимости.

- **`systemd-analyze security`**: провести оценку безопасности службы.
  - Пример: `systemd-analyze security` — отображает оценку безопасности для всех служб.

- **`systemd-analyze verify /path/to/unit/file`**: проверить синтаксис и протестировать конфигурацию файла юнита.
  - Пример: `systemd-analyze verify /etc/systemd/system/nginx.service` — проверяет синтаксис файла юнита для службы Nginx.

### Проверка системных журналов (Check System Logs)

- **`journalctl -u <имя-сервиса>`**: просмотреть логи службы.
  - Пример: `journalctl -u nginx` — выводит журналы службы Nginx.

- **`journalctl -u <имя-сервиса> --boot=-1`**: просмотреть логи службы с последней загрузки системы.
  - Пример: `journalctl -u nginx --boot=-1` — показывает журналы службы Nginx с последней загрузки системы.

# chmod
### Команды `chmod`: установка/изменение прав доступа к файлу для владельца/группы/других пользователей

- **`chmod u+r my.txt`**: предоставить владельцу файла права на чтение.
  - Пример: `chmod u+r my.txt` — добавляет владельцу файла `my.txt` право на чтение.

- **`chmod g-w my.txt`**: удалить у группы право на запись в файл.
  - Пример: `chmod g-w my.txt` — убирает право на запись у группы, связанной с файлом `my.txt`.

- **`chmod u+rwx,o+r my.txt`**: изменить права доступа для владельца и других пользователей одновременно.
  - Пример: `chmod u+rwx,o+r my.txt` — предоставляет владельцу полный доступ, а другим пользователям только право на чтение.

- **`chmod 754 my.txt`**: изменить права доступа к файлу для владельца/группы/других пользователей с использованием числового режима.
  - Пример: `chmod 754 my.txt` — предоставляет владельцу полный доступ, группе — право на чтение и выполнение, другим — только чтение.

### Команды `setfacl`: более точное управление правами доступа к файлам

- **`setfacl -m u:dan:rw my.txt`**: предоставить пользователю `dan` права на чтение/запись.
  - Пример: `setfacl -m u:dan:rw my.txt` — предоставляет пользователю `dan` право на чтение и запись файла `my.txt`.

- **`setfacl -x u:dan my.txt`**: удалить определенные права доступа ACL, предоставленные пользователю `dan`.
  - Пример: `setfacl -x u:dan my.txt` — убирает все ACL-права, предоставленные пользователю `dan` для файла `my.txt`.

- **`setfacl -b my.txt`**: удалить все ACL с файла.
  - Пример: `setfacl -b my.txt` — убирает все ACL для файла `my.txt`.

- **`setfacl -m g:developers:x my.sh`**: предоставить группе `developers` право на выполнение файла.
  - Пример: `setfacl -m g:developers:x my.sh` — добавляет группе `developers` право на выполнение файла `my.sh`.

### Использование команд `find` и `chmod`: изменение прав доступа к нескольким файлам на основе критериев

- **`find . -type f -name "*.sh" -exec chmod +x {} \;`**: установить права на выполнение для всех файлов `.sh`.
  - Пример: `find . -type f -name "*.sh" -exec chmod +x {} \;` — делает исполняемыми все файлы с расширением `.sh` в текущем каталоге.

- **`find . -type f -mtime +30 -exec chmod 444 {} \;`**: установить права только для чтения для всех файлов, измененных более 30 дней назад.
  - Пример: `find . -type f -mtime +30 -exec chmod 444 {} \;` — устанавливает права только для чтения для файлов, измененных более 30 дней назад.

- **`find . -type f -user dan -exec chmod 700 {} \;`**: изменить права доступа для всех файлов пользователя `dan`.
  - Пример: `find . -type f -user dan -exec chmod 700 {} \;` — предоставляет владельцу полный доступ к его файлам.

### Команда `umask`: установить права по умолчанию для вновь создаваемых файлов и директорий

- **`umask 022`**: установить права по умолчанию 644 для файлов и 755 для директорий.
  - Пример: `umask 022` — новые файлы будут создаваться с правами 644, а директории — с правами 755.

### Команда `install`: копирование файлов с установкой прав доступа и владельца в один шаг

- **`install -m 755 my.conf /etc`**: скопировать файл в указанное место и установить права на 755.
  - Пример: `install -m 755 my.conf /etc` — копирует `my.conf` в каталог `/etc` с правами 755.

### Команда `rsync`: установка прав доступа при копировании файлов и директорий с помощью `rsync`

- **`rsync -av --chmod=D2775,F664 src/ dst/`**: установить права доступа для файлов/директорий во время копирования с помощью `rsync`.
  - Пример: `rsync -av --chmod=D2775,F664 src/ dst/` — синхронизирует содержимое `src/` и `dst/` с установкой прав доступа на директории и файлы.

# awk
### Примеры команд `awk` в Linux

- **`awk '{print $2, $3}' my.txt`**: вывести 2-е и 3-е поля, разделенные пробелом.
  - Пример: `awk '{print $2, $3}' my.txt` — выводит содержимое второго и третьего полей в файле `my.txt`.

- **`awk '{print $2 "," $3}' my.txt`**: вывести 2-е и 3-е поля, разделенные запятой.
  - Пример: `awk '{print $2 "," $3}' my.txt` — выводит второе и третье поля в файле `my.txt`, разделяя их запятой.

- **`awk '$2 > 100' my.txt`**: вывести строки, где 2-е поле больше 100.
  - Пример: `awk '$2 > 100' my.txt` — выводит строки, где значение второго поля больше 100.

- **`awk '$1 == 100' my.txt`**: вывести строки, где 1-е поле равно 100.
  - Пример: `awk '$1 == 100' my.txt` — выводит строки, в которых значение первого поля равно 100.

- **`awk '/error/' my.txt`**: вывести строки, содержащие слово "error".
  - Пример: `awk '/error/' my.txt` — выводит все строки, содержащие "error".

- **`awk '{sum += $1 + $2; print sum}' my.txt`**: посчитать сумму 1-го и 2-го полей каждой строки.
  - Пример: `awk '{sum += $1 + $2; print sum}' my.txt` — выводит накопленную сумму первых двух полей каждой строки.

- **`awk '{print NR, $0}' my.txt`**: добавить номер строки перед каждой строкой и вывести.
  - Пример: `awk '{print NR, $0}' my.txt` — выводит содержимое файла `my.txt` с номерами строк.

- **`awk '{print NF}' my.txt`**: вывести количество полей в каждой строке.
  - Пример: `awk '{print NF}' my.txt` — выводит количество полей в каждой строке файла `my.txt`.

- **`awk '{print $1, $NF}' my.txt`**: вывести 1-е и последнее поле.
  - Пример: `awk '{print $1, $NF}' my.txt` — выводит первое и последнее поля в каждой строке файла `my.txt`.

- **`awk '{s += $2; c++} END {print s/c}' my.txt`**: вычислить среднее значение 2-го поля.
  - Пример: `awk '{s += $2; c++} END {print s/c}' my.txt` — вычисляет среднее значение второго поля в файле `my.txt`.

- **`awk '$1 > 100 {s += $2; c++} END {print s/c}' my.txt`**: среднее значение с условием.
  - Пример: `awk '$1 > 100 {s += $2; c++} END {print s/c}' my.txt` — вычисляет среднее значение второго поля для строк, где первое поле больше 100.

- **`awk '{print toupper($2)}' my.txt`**: вывести 2-е поле в верхнем регистре.
  - Пример: `awk '{print toupper($2)}' my.txt` — выводит второе поле в верхнем регистре.

- **`awk '$1 == "ERR" {print $2}' my.log`**: вывести 2-е поле, если 1-е поле равно "ERR".
  - Пример: `awk '$1 == "ERR" {print $2}' my.log` — выводит второе поле для строк, где первое поле равно "ERR".

- **`awk '{print "Имя:", $1, "Возраст:", $2}' my.txt`**: форматированный вывод.
  - Пример: `awk '{print "Имя:", $1, "Возраст:", $2}' my.txt` — выводит значения полей с форматированным текстом.

- **`awk -F "," '{print $2, $3}' my.csv`**: использовать запятую в качестве разделителя полей.
  - Пример: `awk -F "," '{print $2, $3}' my.csv` — выводит второе и третье поля из CSV-файла с разделителем-запятой.

- **`awk '{print substr($2, 1, 3)}' my.txt`**: извлечь подстроку из 2-го поля.
  - Пример: `awk '{print substr($2, 1, 3)}' my.txt` — выводит первые три символа второго поля.

- **`awk 'function sq(x) {return x * x} {print sq($2)}' my.txt`**: определить функцию и использовать её.
  - Пример: `awk 'function sq(x) {return x * x} {print sq($2)}' my.txt` — выводит квадрат значения второго поля.

- **`awk '!seen[$1]++' my.txt`**: удалить дублирующиеся строки на основе 1-го поля.
  - Пример: `awk '!seen[$1]++' my.txt` — выводит строки, исключая дубли по первому полю.

- **`awk 'length($2) > 3' my.txt`**: вывести строки, где длина 2-го поля больше 3.
  - Пример: `awk 'length($2) > 3' my.txt` — выводит строки, где второе поле имеет длину больше 3 символов.

- **`awk '$1 ~ /ERR/' my.log`**: вывести строки, где 1-е поле соответствует шаблону "ERR".
  - Пример: `awk '$1 ~ /ERR/' my.log` — выводит строки, в которых первое поле соответствует шаблону "ERR".

- **`awk '$1 !~ /ERR/' my.log`**: вывести строки, где 1-е поле не соответствует шаблону "ERR".
  - Пример: `awk '$1 !~ /ERR/' my.log` — выводит строки, в которых первое поле не соответствует шаблону "ERR".

- **`awk '$1 ~ /^[0-9]+$/' my.log`**: вывести строки, где 1-е поле является числом.
  - Пример: `awk '$1 ~ /^[0-9]+$/' my.log` — выводит строки, в которых первое поле состоит только из цифр.

# tcpdump
### Примеры команд `tcpdump`

- **`tcpdump`**: прослушивать трафик на первом обнаруженном интерфейсе, не являющемся loopback.
  - Пример: `tcpdump` — начинает захват пакетов на первом доступном интерфейсе, не являющемся loopback (например, `eth0`).

- **`tcpdump -i eth0`**: захватывать пакеты на интерфейсе `eth0` и отображать их содержимое.
  - Пример: `tcpdump -i eth0` — захватывает все пакеты на интерфейсе `eth0`.

- **`tcpdump -i eth0 -w my.pcap`**: сохранять полученные пакеты на `eth0` в файл `my.pcap`.
  - Пример: `tcpdump -i eth0 -w my.pcap` — записывает захваченные пакеты в файл `my.pcap`.

- **`tcpdump -i eth0 arp|tcp|udp|icmp`**: захватывать только определенный протокол.
  - Пример: `tcpdump -i eth0 arp` — захватывает только ARP-пакеты на интерфейсе `eth0`.

- **`tcpdump -i eth0 src 10.0.0.1`**: захватывать трафик с IP-адреса `10.0.0.1`.
  - Пример: `tcpdump -i eth0 src 10.0.0.1` — захватывает все пакеты, исходящие с `10.0.0.1`.

- **`tcpdump -i eth0 port 80`**: захватывать трафик с портом источника или назначения 80.
  - Пример: `tcpdump -i eth0 port 80` — захватывает HTTP-трафик.

- **`tcpdump -i eth0 src 10.0.0.1 and port 80`**: комбинировать несколько фильтров.
  - Пример: `tcpdump -i eth0 src 10.0.0.1 and port 80` — захватывает HTTP-трафик, исходящий с `10.0.0.1`.

- **`tcpdump -i eth0 -vvv`**: отображать информацию о протоколе с полной детализацией.
  - Пример: `tcpdump -i eth0 -vvv` — выводит более подробную информацию о захваченных пакетах.

- **`tcpdump -i eth0 not port 22`**: захватывать весь трафик, кроме SSH-трафика.
  - Пример: `tcpdump -i eth0 not port 22` — исключает пакеты SSH из захвата.

- **`tcpdump -i eth0 -c 1000`**: захватывать только первые 1000 пакетов.
  - Пример: `tcpdump -i eth0 -c 1000` — прекращает захват после получения 1000 пакетов.

- **`tcpdump -i eth0 -tt`**: использовать метку времени UNIX в качестве формата временной метки пакета.
  - Пример: `tcpdump -i eth0 -tt` — выводит временные метки пакетов в формате UNIX.

- **`tcpdump -i eth0 -n`**: не преобразовывать IP-адреса и порты в имена.
  - Пример: `tcpdump -i eth0 -n` — отключает разрешение имен для IP-адресов и портов.

- **`tcpdump -i any`**: захватывать пакеты со всех доступных интерфейсов.
  - Пример: `tcpdump -i any` — захватывает пакеты с любого сетевого интерфейса.

- **`tcpdump -i eth0 -e`**: отображать информацию уровня 2, такую как MAC-адреса.
  - Пример: `tcpdump -i eth0 -e` — выводит MAC-адреса в захваченных пакетах.

- **`tcpdump -i eth0 dst net 10.1.1.0/24`**: захватывать трафик для определенной подсети.
  - Пример: `tcpdump -i eth0 dst net 10.1.1.0/24` — захватывает пакеты, направленные на подсеть `10.1.1.0/24`.

- **`tcpdump -i eth0 ip6`**: захватывать только пакеты IPv6.
  - Пример: `tcpdump -i eth0 ip6` — захватывает только IPv6-трафик.

- **`tcpdump -i eth0 'tcp port 80 or udp port 67'`**: использовать сложные фильтры.
  - Пример: `tcpdump -i eth0 'tcp port 80 or udp port 67'` — захватывает HTTP- и DHCP-пакеты.

- **`tcpdump -i eth0 dst portrange 22-1023`**: захватывать пакеты с диапазоном портов.
  - Пример: `tcpdump -i eth0 dst portrange 22-1023` — захватывает пакеты, направленные на порты от 22 до 1023.

- **`tcpdump -i eth0 greater 200`**: захватывать пакеты, длина которых больше 200 байт.
  - Пример: `tcpdump -i eth0 greater 200` — захватывает пакеты, размер которых превышает 200 байт.

- **`tcpdump ether dst ff:ff:ff:ff:ff:ff`**: захватывать широковещательные пакеты уровня 2.
  - Пример: `tcpdump ether dst ff:ff:ff:ff:ff:ff` — захватывает все широковещательные пакеты.

- **`tcpdump -i eth0 'tcp[tcpflags] & tcp-syn!=0'`**: захватывать TCP/SYN пакеты.
  - Пример: `tcpdump -i eth0 'tcp[tcpflags] & tcp-syn!=0'` — захватывает пакеты с установленным флагом SYN (начало TCP-соединения).

- **`tcpdump -i eth0 -e vlan 10`**: захватывать трафик с VLAN тегом 10.
  - Пример: `tcpdump -i eth0 -e vlan 10` — захватывает пакеты, передаваемые через VLAN с тегом 10.

- **`tcpdump -i eth0 outbound`**: захватывать только исходящий трафик.
  - Пример: `tcpdump -i eth0 outbound` — захватывает пакеты, отправляемые с интерфейса `eth0`.

# ps
### Примеры команд `ps` в Linux

- **`ps`**: отображает процессы для текущей сессии терминала.
  - Пример: `ps` — показывает список процессов, связанных с текущим терминалом.

- **`ps -e`**: выводит список всех процессов в системе.
  - Пример: `ps -e` — отображает все активные процессы в системе.

- **`ps -l`**: выводит подробный список процессов, включая аргументы командной строки.
  - Пример: `ps -l` — отображает детализированную информацию о процессах.

- **`ps -eF`**: выводит подробную информацию обо всех процессах.
  - Пример: `ps -eF` — показывает полную информацию обо всех процессах.

- **`ps -u <имя_пользователя>`**: выводит процессы, запущенные от имени конкретного пользователя.
  - Пример: `ps -u username` — отображает процессы, запущенные пользователем `username`.

- **`ps -p PID1,PID2`**: выводит процессы с указанными идентификаторами (PID).
  - Пример: `ps -p 1234,5678` — показывает процессы с PID 1234 и 5678.

- **`ps -e --no-headers`**: отображает процессы без заголовков.
  - Пример: `ps -e --no-headers` — выводит список процессов без строк заголовков.

- **`ps -eLf`**: показывает все потоки для всех процессов.
  - Пример: `ps -eLf` — отображает информацию о потоках для каждого процесса.

- **`ps -T -p PID`**: выводит все потоки для процесса с указанным PID.
  - Пример: `ps -T -p 1234` — отображает все потоки процесса с PID 1234.

- **`ps -t pts/0`**: отображает процессы, созданные в указанном терминале.
  - Пример: `ps -t pts/0` — выводит процессы, работающие в терминале `pts/0`.

- **`ps -e | grep "?"`**: выводит процессы, не связанные с терминалом.
  - Пример: `ps -e | grep "?"` — показывает процессы, которые не привязаны к конкретному терминалу.

- **`ps -eH`**: выводит все процессы в иерархическом формате (родитель-потомок).
  - Пример: `ps -eH` — показывает процессы с отображением их структуры (родители и дочерние процессы).

- **`ps -fG root`**: выводит процессы, связанные с определенной группой (например, `root`).
  - Пример: `ps -fG root` — показывает процессы, запущенные от имени группы `root`.

- **`ps -eo pid,user,comm`**: выводит информацию о процессах в формате, заданном пользователем.
  - Пример: `ps -eo pid,user,comm` — отображает PID, имя пользователя и команду для каждого процесса.

- **`ps -eo pid,%cpu,%mem,comm`**: отображает использование ресурсов процессами.
  - Пример: `ps -eo pid,%cpu,%mem,comm` — выводит PID, использование процессора и памяти, а также команду.

- **`ps -eo pid,comm,lstart,etime`**: отображает время запуска и продолжительность выполнения процесса.
  - Пример: `ps -eo pid,comm,lstart,etime` — показывает PID, команду, время запуска и длительность выполнения.

- **`ps -eo pid,comm,psr`**: отображает процессы вместе с их привязкой к процессорным ядрам (CPU affinity).
  - Пример: `ps -eo pid,comm,psr` — показывает PID, команду и привязку к процессорным ядрам.

- **`ps aux --sort=-%mem | head`**: выводит список процессов, отсортированный по использованию памяти.
  - Пример: `ps aux --sort=-%mem | head` — показывает процессы, занимающие больше всего памяти.

- **`ps aux --sort=-%cpu | head`**: выводит список процессов, отсортированный по использованию процессора.
  - Пример: `ps aux --sort=-%cpu | head` — показывает процессы, потребляющие больше всего процессорного времени.

- **`ps aux | grep 'Z'`**: выводит все процессы-зомби.
  - Пример: `ps aux | grep 'Z'` — показывает процессы, находящиеся в состоянии "зомби".

- **`ps auxww`**: отображает полную командную строку всех процессов без обрезки.
  - Пример: `ps auxww` — выводит полные команды, с которыми запущены процессы.

- **`watch "ps aux --sort=-%cpu | head"`**: мониторинг процессов, потребляющих много CPU в реальном времени.
  - Пример: `watch "ps aux --sort=-%cpu | head"` — показывает процессы, занимающие много CPU, и обновляет данные в реальном времени.

# cron
### Формат Cron
```
*     *     *     *     *     <команда для выполнения>
-     -     -     -     -
|     |     |     |     |
|     |     |     |     +---- день недели (0 - Воскресенье, 1 - Понедельник, ..., 6 - Суббота)
|     |     |     +---------- месяц (1 - Январь, 2 - Февраль, ..., 12 - Декабрь)
|     |     +--------------- день месяца (1 - 31)
|     +-------------------- час (0 - 23)
+------------------------- минуты (0 - 59)
```

### Примеры Cron-заданий

- `0 0 * * * /opt/backup.sh`: выполнять резервное копирование системы каждый день в полночь.
- `*/7 * * * * /opt/check.sh`: проверять, доступен ли сервер, каждые 7 минут.
- `0 */6 * * * /opt/cleanup.sh`: очищать корзину каждые 6 часов.
- `20 14 * * * /opt/upgrade.sh`: выполнять обновление системы в 14:20 каждый день.
- `0 9 1 4 * /opt/upgrade.sh`: обновлять систему в 09:00 1 апреля.
- `0 11 * * 3 /opt/update.sh`: обновлять систему в 11:00 каждую среду.
- `0 22 * * 1-5 /opt/upgrade.sh`: обновлять систему в 22:00 с понедельника по пятницу.
- `0 0 1 * * /opt/check.sh`: выполнять задание в полночь 1-го числа каждого месяца.
- `0 8 5 11 * /opt/monitor.sh`: мониторинг системы в 08:10 в последний четверг каждого месяца.
- `15 14 1 * 4 /opt/upgrade.sh`: обновлять систему в 14:15 первого числа на второй четверг апреля.
- `0 5 31 12 0 /opt/backup.sh`: выполнять резервное копирование в 05:00 31 декабря.
- `0 0 * * 0 /opt/emptytrash.sh`: очищать корзину в 12:05 каждое воскресенье.
- `@reboot /opt/backup.sh`: выполнять резервное копирование при загрузке системы.

### Специальные строки

- **`@reboot`**: запускать команду при загрузке системы.
- **`@hourly`**: запускать команду каждый час.
- **`@daily`**: запускать команду каждый день.
- **`@midnight`**: запускать команду в полночь (аналогично `@daily`).
- **`@weekly`**: запускать команду каждую неделю.
- **`@monthly`**: запускать команду каждый месяц.
- **`@yearly`**: запускать команду каждый год.

### Специальные символы

- **Звездочка (*)**: используется для представления всех возможных значений в поле.
- **Тире (-)**: используется для задания диапазона значений, например, `1-5`.
- **Запятая (,)**: используется для перечисления нескольких значений, например, `1,15`.
- **Слэш (/)**: используется для задания шага, например, `*/2` для выполнения через каждые 2 единицы.
- **L**: используется в поле дня месяца или дня недели для указания последнего дня месяца или недели.
- **W**: используется для выбора ближайшего рабочего дня.
- **#**: используется для указания определенной недели в месяце, например, `5#2` для второй пятницы.
- **?**: используется вместо `*` для полей "день месяца" и "день недели", чтобы задать отсутствие значения.

### Команды Crontab

- **`crontab -e`**: открыть или создать файл crontab, если он не существует.
- **`crontab -l`**: отобразить текущие задания crontab.
- **`crontab -r`**: удалить файл crontab.
- **`crontab -u <имя_пользователя> -e`**: редактировать crontab другого пользователя.
- **`crontab -u <имя_пользователя> -l`**: отобразить последний раз отредактированный crontab для пользователя.

# nmcli
### Просмотр конфигурации сети
- **`nmcli general status`**: показать статус менеджера сетей.
  - Пример: `nmcli general status` — отображает текущее состояние NetworkManager.

- **`nmcli device`**: показать доступные сетевые устройства и их состояние.
  - Пример: `nmcli device` — выводит список всех сетевых интерфейсов и их текущий статус.

- **`nmcli connection`**: показать все сетевые подключения.
  - Пример: `nmcli connection show` — отображает все настроенные сетевые подключения.

- **`nmcli device show <имя-устройства>`**: показать детали конфигурации устройства.
  - Пример: `nmcli device show eth0` — выводит детальную информацию о сетевом интерфейсе `eth0`.

### Управление сетевыми устройствами
- **`nmcli device connect|disconnect <имя-устройства>`**: подключить или отключить устройство.
  - Пример: `nmcli device disconnect wlan0` — отключает беспроводное устройство `wlan0`.
  - Пример: `nmcli device connect eth0` — подключает проводное устройство `eth0`.

- **`nmcli device reapply <имя-устройства>`**: повторно применить сетевые настройки к устройству.
  - Пример: `nmcli device reapply eth0` — повторно применяет текущие сетевые настройки для `eth0`.

- **`nmcli device monitor`**: отображать обновления статуса устройства в реальном времени.
  - Пример: `nmcli device monitor` — показывает изменения статуса всех сетевых устройств в реальном времени.

### Управление конфигурацией Wi-Fi
- **`nmcli radio wifi on|off`**: включить или отключить Wi-Fi.
  - Пример: `nmcli radio wifi off` — отключает Wi-Fi на устройстве.
  - Пример: `nmcli radio wifi on` — включает Wi-Fi.

- **`nmcli device wifi list`**: показать доступные Wi-Fi сети.
  - Пример: `nmcli device wifi list` — выводит список всех доступных Wi-Fi сетей.

- **`nmcli device wifi rescan`**: повторно просканировать доступные Wi-Fi сети.
  - Пример: `nmcli device wifi rescan` — обновляет список доступных Wi-Fi сетей.

- **`nmcli device wifi connect <SSID> password <пароль>`**: подключиться к Wi-Fi сети.
  - Пример: `nmcli device wifi connect MyWiFi password 12345678` — подключается к Wi-Fi сети с именем `MyWiFi` и паролем `12345678`.

- **`nmcli con add type wifi ifname <имя-устройства> ssid <SSID>`**: добавить Wi-Fi подключение.
  - Пример: `nmcli con add type wifi ifname wlan0 ssid MyWiFi` — добавляет новое Wi-Fi подключение с именем `MyWiFi` для устройства `wlan0`.

- **`nmcli con modify <имя-подключения> wifi-sec.key-mgmt wpa-psk`**: использовать WPA-PSK для безопасности Wi-Fi.
  - Пример: `nmcli con modify MyWiFi wifi-sec.key-mgmt wpa-psk` — изменяет настройки безопасности для подключения `MyWiFi` на WPA-PSK.

- **`nmcli con modify <имя-подключения> wifi-sec.psk <ключ>`**: установить предварительно разделяемый ключ (PSK) для WPA.
  - Пример: `nmcli con modify MyWiFi wifi-sec.psk 12345678` — устанавливает ключ WPA-PSK для подключения `MyWiFi`.

### Управление другими типами сетевых подключений
- **`nmcli con add type ethernet ifname <имя-устройства>`**: добавить проводное подключение.
  - Пример: `nmcli con add type ethernet ifname eth0` — добавляет новое проводное подключение для устройства `eth0`.

- **`nmcli con modify <имя-подключения> ipv4.method manual`**: установить статический IP-адрес.
  - Пример: `nmcli con modify eth0 ipv4.method manual ipv4.addresses 192.168.1.10/24` — задает статический IP-адрес `192.168.1.10` для устройства `eth0`.

- **`nmcli con modify <имя-подключения> ipv4.gateway <шлюз>`**: настроить шлюз по умолчанию.
  - Пример: `nmcli con modify eth0 ipv4.gateway 192.168.1.1` — задает шлюз по умолчанию для подключения `eth0`.

- **`nmcli con modify <имя-подключения> ipv4.dns "8.8.8.8 8.8.4.4"`**: настроить DNS-серверы.
  - Пример: `nmcli con modify eth0 ipv4.dns "8.8.8.8 8.8.4.4"` — добавляет DNS-серверы Google (`8.8.8.8` и `8.8.4.4`) для подключения `eth0`.

- **`nmcli con up <имя-подключения>`**: применить изменения.
  - Пример: `nmcli con up eth0` — активирует и применяет все изменения для подключения `eth0`.

# journalctl
### Команды `journalctl` для работы с системными журналами

- **`journalctl`**: отображает все журналы systemd.
  - Пример: `journalctl` — выведет все записи из системных журналов.

- **`journalctl -f`**: следить за логами в реальном времени (аналогично `tail -f`).
  - Пример: `journalctl -f` — покажет обновления логов в реальном времени.

- **`journalctl --no-page`**: показать логи без постраничной разбивки.
  - Пример: `journalctl --no-page` — выведет все логи сразу, без разбивки на страницы.

- **`journalctl -u <имя-сервиса>`**: показать логи для конкретного сервиса.
  - Пример: `journalctl -u nginx.service` — выведет логи для сервиса Nginx.

- **`journalctl --since "xxx" --until "xxx"`**: показать логи за определенный период времени.
  - Пример: `journalctl --since "2023-08-01" --until "2023-08-10"` — покажет логи за указанный период.

- **`journalctl _UID=1000 --since today`**: показать логи для конкретного UID за сегодняшний день.
  - Пример: `journalctl _UID=1000 --since today` — выведет логи для пользователя с UID 1000 за текущий день.

- **`journalctl _PID=5000`**: показать логи для конкретного процесса по PID.
  - Пример: `journalctl _PID=5000` — выведет логи процесса с PID 5000.

- **`journalctl _EXE=/usr/bin/docker`**: показать логи для конкретного исполняемого файла.
  - Пример: `journalctl _EXE=/usr/bin/docker` — покажет логи, связанные с запуском `docker`.

- **`journalctl -k`**: показать только логи ядра.
  - Пример: `journalctl -k` — выведет логи, относящиеся к ядру системы.

- **`journalctl -r`**: отобразить логи в обратном порядке (сначала новые записи).
  - Пример: `journalctl -r` — выведет логи, начиная с самых последних записей.

- **`journalctl -p err`**: фильтровать логи по приоритету (например, `err`, `warning`, `info`, `debug`).
  - Пример: `journalctl -p err` — покажет только ошибки (приоритет "error").

- **`journalctl --list-boots`**: показать список всех сессий загрузки системы.
  - Пример: `journalctl --list-boots` — выведет список всех загрузок системы с указанием их идентификаторов.

- **`journalctl -b`**: показать логи текущей сессии загрузки.
  - Пример: `journalctl -b` — выведет логи, начиная с последней загрузки системы.

- **`journalctl -b -1`**: показать логи предыдущей сессии загрузки.
  - Пример: `journalctl -b -1` — выведет логи, начиная с предпоследней загрузки.

- **`journalctl --grep "pattern"`**: фильтровать логи по указанному шаблону или строке.
  - Пример: `journalctl --grep "error"` — покажет логи, содержащие слово "error".

- **`journalctl -o json-pretty`**: отобразить логи в формате JSON для удобства парсинга.
  - Пример: `journalctl -o json-pretty` — выведет логи в красивом формате JSON.

- **`journalctl --disk-usage`**: показать размер журнала.
  - Пример: `journalctl --disk-usage` — покажет, сколько места занимают журналы на диске.

- **`journalctl --rotate`**: поворот (ротация) файлов журналов.
  - Пример: `journalctl --rotate` — выполнит ротацию журналов (создание новых файлов для журналов).

- **`journalctl --vacuum-time=2weeks`**: удалить журналы старше 2 недель.
  - Пример: `journalctl --vacuum-time=2weeks` — удалит все журналы, старше двух недель.

- **`journalctl --vacuum-size=500M`**: ограничить размер журнала до 500 МБ.
  - Пример: `journalctl --vacuum-size=500M` — удалит самые старые записи, чтобы общий размер журналов не превышал 500 МБ.

- **`journalctl --vacuum-files=10`**: уменьшить количество файлов журналов до 10.
  - Пример: `journalctl --vacuum-files=10` — удалит старые файлы журналов, оставив только 10 последних.

- **`journalctl -o export > /path/to/out.journal`**: экспортировать журналы в бинарном формате.
  - Пример: `journalctl -o export > /path/to/out.journal` — экспортирует все журналы в бинарный файл для дальнейшего анализа.

# curl
### Операция HTTP GET
- **`curl http://abc.com`**: получить URL и вывести его содержимое.
  - Пример: `curl http://abc.com` — отобразит содержимое страницы.

- **`curl -o output.txt http://abc.com`**: сохранить ответ в файл.
  - Пример: `curl -o output.txt http://abc.com` — сохранит содержимое страницы в файл `output.txt`.

- **`curl -A "Mozilla/5.0" http://abc.com`**: задать `user-agent`.
  - Пример: `curl -A "Mozilla/5.0" http://abc.com` — выполнит запрос с `user-agent`, как у браузера Mozilla.

- **`curl -e http://referer.com http://abc.com`**: указать `referrer`.
  - Пример: `curl -e http://referer.com http://abc.com` — выполнит запрос с указанным `referrer`.

- **`curl -x http://proxy.com:port http://abc.com`**: использовать HTTP-прокси.
  - Пример: `curl -x http://proxy.com:8080 http://abc.com` — выполнит запрос через прокси-сервер на порту 8080.

- **`curl -H "Authorization: bearer-token" http://abc.com`**: использовать кастомные заголовки.
  - Пример: `curl -H "Authorization: Bearer token" http://abc.com` — выполнит запрос с заголовком авторизации.

- **`curl -u username:password http://abc.com`**: использовать аутентификацию пользователя.
  - Пример: `curl -u user:pass http://abc.com` — выполнит запрос с использованием логина и пароля.

- **`curl -L http://abc.com`**: следовать всем перенаправлениям до достижения конечного адреса.
  - Пример: `curl -L http://abc.com` — будет следовать за всеми перенаправлениями.

- **`curl -b /path/to/cookie http://abc.com`**: прочитать локальный файл cookie.
  - Пример: `curl -b /path/to/cookie.txt http://abc.com` — выполнит запрос с использованием данных cookie из файла.

- **`curl -c /path/to/cookie http://abc.com`**: записать полученные cookie в файл.
  - Пример: `curl -c /path/to/cookie.txt http://abc.com` — сохранит cookie в файл `cookie.txt`.

- **`curl --compressed http://abc.com`**: автоматически декомпрессировать ответ.
  - Пример: `curl --compressed http://abc.com` — декомпрессирует сжатый ответ сервера.

### Операции HTTP POST/PUT
- **`curl -X POST -d "key1=val1&key2=val2" http://abc.com`**: указать пары ключ-значение в POST-запросе.
  - Пример: `curl -X POST -d "name=John&age=30" http://abc.com` — выполнит POST-запрос с данными.

- **`curl -X POST -d '{"k1":"v1"}' -H "Content-Type: application/json" http://abc.com`**: использовать данные JSON.
  - Пример: `curl -X POST -d '{"name":"John"}' -H "Content-Type: application/json" http://abc.com` — выполнит POST-запрос с JSON.

- **`curl -X POST -F "name=dan" -F "file=@/path/to/file.txt" http://abc.com`**: загрузить файл.
  - Пример: `curl -X POST -F "name=dan" -F "file=@/home/user/file.txt" http://abc.com` — загрузит файл на сервер.

- **`curl -X POST --data-binary @/path/to/file.bin http://abc.com`**: загрузить бинарный файл.
  - Пример: `curl -X POST --data-binary @/home/user/file.bin http://abc.com` — загрузит бинарный файл.

- **`curl -X PUT -d "key1=val1&key2=val2" http://abc.com`**: указать пары ключ-значение в PUT-запросе.
  - Пример: `curl -X PUT -d "name=John&age=30" http://abc.com` — выполнит PUT-запрос с данными.

### Операции загрузки файлов
- **`curl -O http://abc.com/file.zip`**: загрузить файл и сохранить его под тем же именем.
  - Пример: `curl -O http://abc.com/file.zip` — загрузит файл `file.zip` в текущий каталог.

- **`curl -C - http://abc.com/file.zip`**: продолжить прерванную загрузку.
  - Пример: `curl -C - http://abc.com/file.zip` — продолжит загрузку файла с места остановки.

- **`curl --limit-rate 1M -O http://abc.com/file.zip`**: ограничить скорость загрузки до 1 МБ/с.
  - Пример: `curl --limit-rate 1M -O http://abc.com/file.zip` — будет загружать файл со скоростью не более 1 МБ/с.

- **`curl -remote-name-all http://abc.com/img[1-10].jpg`**: загрузить несколько файлов.
  - Пример: `curl -remote-name-all http://abc.com/img[1-10].jpg` — скачает файлы `img1.jpg`, `img2.jpg`, ..., `img10.jpg`.

- **`curl http://{foo,bar}.com/index.htm --output "#1.htm"`**: загрузить файл из нескольких доменов.
  - Пример: `curl http://{site1,site2}.com/index.htm --output "#1.htm"` — скачает `index.htm` с двух доменов и сохранит их как `site1.htm` и `site2.htm`.

# wbinfo

### `wbinfo`
**Описание**: Команда `wbinfo` используется для запроса информации из базы данных пользователей и групп, обслуживаемой `winbindd`, который является компонентом пакета Samba, позволяющего Unix/Linux машинам взаимодействовать с Windows NT/2000/XP системами в домене Active Directory.

**Примеры**:
- Получение списка доменных пользователей:
  ```bash
  wbinfo -u
  ```
- Получение списка доменных групп:
  ```bash
  wbinfo -g
  ```
- Получение SID доменного пользователя:
  ```bash
  wbinfo -n username
  ```
- Проверка доменного имени пользователя:
  ```bash
  wbinfo -i username
  ```
# smbpasswd

### `smbpasswd`
**Описание**: Команда `smbpasswd` используется для управления паролями учетных записей пользователей в базе данных учетных записей Samba (обычно это файл `/etc/samba/smbpasswd`). Она позволяет добавлять пользователей, изменять пароли и удалять учетные записи пользователей для доступа к ресурсам Samba.

**Примеры**:
- Добавление нового пользователя в базу данных Samba:
  ```bash
  sudo smbpasswd -a username
  ```
- Изменение пароля пользователя:
  ```bash
  sudo smbpasswd username
  ```
- Отключение пользователя в Samba:
  ```bash
  sudo smbpasswd -d username
  ```
- Удаление пользователя из базы данных Samba:
  ```bash
  sudo smbpasswd -x username
  ```

# gpasswd

###`gpasswd`
**Описание**: Команда `gpasswd` используется для управления членством в группах в системе Unix/Linux. Она позволяет добавлять и удалять пользователей из групп, а также управлять паролями групп.

**Примеры**:
- Добавление пользователя в группу:
  ```bash
  sudo gpasswd -a username groupname
  ```
- Удаление пользователя из группы:
  ```bash
  sudo gpasswd -d username groupname
  ```
- Назначение администратора группы:
  ```bash
  sudo gpasswd -A username groupname
  ```
- Установка пароля для группы:
  ```bash
  sudo gpasswd groupname
  ```

# id
### `id -Gn admin`
**Описание**: Команда `id` используется для получения информации о пользователе. Ключ `-Gn` выводит список групп, в которых состоит пользователь, указанный после команды. В данном случае, команда `id -Gn admin` выводит список всех групп, к которым принадлежит пользователь `admin`.

**Пример**:
- Вывод списка групп, к которым принадлежит пользователь `admin`:
  ```bash
  id -Gn admin
  ```
  Пример вывода:
  ```
  admin sudo users wheel
  ```

# Команды pacman для Linux

**pacman** — это менеджер пакетов для Arch Linux и его производных.

## Установка, обновление и удаление пакетов

- `pacman -S <pkg-name>` — установить пакет вместе с его зависимостями.
- `pacman -U /path/to/package.pkg.tar.zst` — установить локальный пакет не из репозитория.
- `pacman -Syu` — обновить все установленные пакеты.
- `pacman -Syu --ignore <pkg-name>` — обновить систему, игнорируя указанный пакет.
- `pacman -S <pkg-name>=<version>` — установить конкретную версию пакета.
- `pacman -R <pkg-name>` — удалить пакет без удаления зависимостей.
- `pacman -Rs <pkg-name>` — удалить пакет вместе с его зависимостями.
- `pacman -Rns $(pacman -Qdtq)` — очистить ненужные зависимости.
- `pacman -Rdd <pkg-name>` — принудительно удалить пакет без его зависимостей.
- `pacman -Sc` — удалить старые версии установленных пакетов из кеша.
- `pacman -Scc` — полностью очистить кеш пакетов для экономии места.

## Поиск пакетов

- `pacman -Sy` — обновить локальную базу данных пакетов с информацией из удалённых репозиториев.
- `pacman -Ss <search-term>` — выполнить поиск пакетов в базе данных.
- `pacman -Ss 'vim'` — искать пакеты, содержащие указанное имя.
- `pacman -Qs <string>` — искать уже установленные пакеты.
- `pacman -F <string>` — искать файл по его имени в удалённых репозиториях.

## Информация о пакетах

- `pacman -Q` — показать список всех установленных пакетов.
- `pacman -Ql <pkg-name>` — показать файлы, установленные с пакетом.
- `pacman -Qo /path/to/file` — показать, какой пакет предоставляет указанный файл.
- `pacman -Qe` — показать установленные вручную пакеты (без зависимостей).
- `pacman -Si <pkg-name>` — показать детальную информацию о пакете.
- `pacman -Qi <pkg-name>` — показать информацию о установленном пакете.
- `pacman -Qdt` — показать «осиротевшие» пакеты, которые больше не нужны как зависимости.
- 

# Debian 10, 11 repository
## Debian 11
```bash
# YANDEX
# Основные репозитории
deb http://mirror.yandex.ru/debian/ bullseye main
deb-src http://mirror.yandex.ru/debian/ bullseye main

# Обновления безопасности
deb http://mirror.yandex.ru/debian-security bullseye-security main contrib
deb-src http://mirror.yandex.ru/debian-security bullseye-security main contrib

# Официальные обновления системы (включая исправления ошибок и уязвимостей)
deb http://mirror.yandex.ru/debian/ bullseye-updates main contrib
deb-src http://mirror.yandex.ru/debian/ bullseye-updates main contrib
```
## Debian 10
```bash
# YANDEX
# Основные репозитории
deb http://mirror.yandex.ru/debian/ buster main
deb-src http://mirror.yandex.ru/debian/ buster main

# Обновления безопасности
deb http://mirror.yandex.ru/debian-security buster/updates main contrib
deb-src http://mirror.yandex.ru/debian-security buster/updates main contrib

# Официальные обновления системы (включая исправления ошибок и уязвимостей)
deb http://mirror.yandex.ru/debian/ buster-updates main contrib
deb-src http://mirror.yandex.ru/debian/ buster-updates main contrib
```

# sync, freeze
Команды `sync` и `fsfreeze` используются для управления файловой системой в Linux, и каждая из них имеет свои особенности и задачи.

### 1. **Команда `sync`**
Команда `sync` предназначена для сброса данных, находящихся в кэше, на диск. Когда система записывает данные, они могут временно храниться в кэше (в оперативной памяти), чтобы ускорить операции чтения и записи. Команда `sync` заставляет операционную систему сбросить все данные на диск, что помогает предотвратить потерю данных при внезапных отключениях или перезагрузках системы.

#### Примеры использования `sync`:
1. **Простой вызов `sync`**:
   ```bash
   sync
   ```
   Это сбросит все данные файловой системы, находящиеся в кэше, на диск. Система завершит операцию записи на всех подключенных дисках.

2. **Использование с конкретным устройством**:
   ```bash
   sync /dev/sdb1
   ```
   Сбрасывает кэш только для указанного устройства `/dev/sdb1`.

3. **Перед выполнением критической операции (например, перезагрузки)**:
   Иногда команду `sync` используют перед выключением или перезагрузкой сервера, чтобы убедиться, что все данные записаны на диск:
   ```bash
   sync && reboot
   ```

### 2. **Команда `fsfreeze`**
Команда `fsfreeze` используется для временной "заморозки" (приостановки) всех операций записи на файловую систему. Это полезно, когда нужно создать консистентные снимки (например, с помощью LVM или внешних инструментов для создания снимков томов), или для выполнения резервного копирования, так как это гарантирует, что во время создания снимка файловая система не будет изменяться.

#### Примеры использования `fsfreeze`:

1. **Заморозка файловой системы**:
   ```bash
   sudo fsfreeze -f /mnt/data
   ```
   Это замораживает файловую систему, смонтированную в `/mnt/data`. Все операции записи приостанавливаются, но процессы остаются в ожидании, пока файловая система не будет разморожена.

2. **Размораживание файловой системы**:
   ```bash
   sudo fsfreeze -u /mnt/data
   ```
   Это размораживает файловую систему, что позволяет продолжить операции записи.

3. **Создание снимка с использованием `fsfreeze`**:
   Заморозка файловой системы перед созданием снимка:
   ```bash
   sudo fsfreeze -f /mnt/data
   sudo lvcreate --snapshot --name snap /dev/vg0/lv0
   sudo fsfreeze -u /mnt/data
   ```
   В этом примере файловая система на `/mnt/data` замораживается перед созданием LVM-снимка, чтобы гарантировать, что данные остаются консистентными во время создания снимка.

#### Полезные флаги:
- `-f`: "Заморозить" файловую систему (freeze).
- `-u`: "Разморозить" файловую систему (unfreeze).

### Важные замечания:
- **`sync`** — это команда, которая только сбрасывает данные на диск, не останавливая операции записи.
- **`fsfreeze`** — это более мощный инструмент, который останавливает все операции записи до тех пор, пока файловая система не будет "разморожена".


# Сочетания клавиш редактора Nano

## Обработка файлов

- **Ctrl+S** Сохранить текущий файл
- **Ctrl+O** Сохранить как файл
- **Ctrl+R** Вставить файл в текущий
- **Ctrl+X** Закрыть буфер и выйти

## Редактирование

- **Ctrl+K** Вырезать текущую строку в буфер
- **Alt+6** Копировать текущую строку в буфер
- **Ctrl+U** Вставить содержимое буфера
- **Ctrl+L** Завершить текущее слово
- **Alt+3** Закомментировать/раскомментировать строку/блок
- **Alt+U** Отменить последнее действие
- **Alt+E** Повторить последнее отменённое действие
- **Ctrl+Shift+6, Ctrl+U** Выделить весь текст

## Поиск и замена

- **Ctrl+F** Начать поиск вперёд
- **Ctrl+B** Начать поиск назад
- **Ctrl+W** Найти следующее вхождение вперёд
- **Ctrl+B** Найти следующее вхождение назад
- **Alt+R** Начать сессию замены

## Удаление

- **Ctrl+H** Удалить символ перед курсором
- **Ctrl+D** Удалить символ под курсором
- **Alt+Bsp** Удалить слово влево
- **Ctrl+Del** Удалить слово вправо
- **Alt+Del** Удалить текущую строку
- **Ctrl+K, Ctrl+K (многократно)** Удалить весь текст (повторное нажатие Ctrl+K удаляет строки подряд)

## Информация

- **Ctrl+C** Показать позицию курсора
- **Ctrl+D** Показать количество слов/символов
- **Ctrl+G** Показать справку

## Перемещение курсора

- **→/←** Один символ вперед или назад
- **Ctrl+→/←** Одно слово вперед или назад
- **Ctrl+A/E** В начало или конец строки
- **Ctrl+P/N** Одну строку вверх или вниз
- **Ctrl+→/←** К предыдущему или следующему блоку
- **Alt+Home** В начало текущего окна
- **Alt+End** В конец текущего окна
- **Ctrl+Y/V** На одну страницу вверх или вниз
- **Alt+\** В начало буфера
- **Alt+/** В конец буфера
- **Alt+G** Перейти к указанной строке
- **Alt+]** К соответствующей скобке
- **Alt+↑/↓** Прокрутка окна вверх или вниз
- **Alt+<** Переключиться на предыдущий буфер
- **Alt+>** Переключиться на следующий буфер

## Разное

- **Ctrl+T** Выполнить внешнюю команду
- **Ctrl+T Ctrl+S** Запустить проверку орфографии
- **Ctrl+T Ctrl+X** Запустить проверку синтаксиса
- **Ctrl+T Ctrl+O** Запустить форматтер
- **Tab** Сделать отступ выделенной области
- **Shift+Tab** Убрать отступ выделенной области
- **Alt+A** Установить или снять метку
- **Alt+V** Ввести следующую клавишу дословно
- **Alt+N** Включить/выключить номера строк
- **Alt+P** Включить/выключить видимые пробелы
- **Alt+S** Включить/выключить перенос слов
- **Ctrl+L** Обновить экран

# Инструменты для защиты Linux

## Firewall (Межсетевые экраны)
- **nftables**: Современный фреймворк для фильтрации сетевых пакетов в Linux.
- **Vuurmuur**: Удобный интерфейс для iptables с поддержкой правил и журналов.
- **Firewalld**: Динамический интерфейс для управления iptables с зонами безопасности.
- **ufw**: Упрощённый интерфейс для iptables, часто используется в Ubuntu.
- **Firejail**: Инструмент для сэндбоксинга приложений и ограничения их привилегий.

## Sandboxing (Сэндбоксинг)
- **Bubblewrap**: Лёгкий инструмент для контейнеризации и сэндбоксинга приложений.
- **Seccomp**: Механизм ядра для ограничения системных вызовов, которые могут выполнять процессы.
- **Firejail**: Ограничение привилегий и изоляция приложений.
  
## Intrusion Detection (Обнаружение вторжений)
- **Snort**: Система обнаружения вторжений с поддержкой глубокого анализа пакетов.
- **Suricata**: Высокопроизводительная система обнаружения угроз и мониторинга трафика.

## Log Monitoring (Мониторинг логов)
- **Zeek**: Платформа для анализа сетевой безопасности.
- **Netdata**: Инструмент мониторинга состояния системы в реальном времени.
- **logwatch**: Утилита для сбора и анализа логов системы.

## File Integrity Monitoring (Мониторинг целостности файлов)
- **AIDE**: Инструмент для мониторинга целостности файлов.
- **Tripwire**: Программа для мониторинга изменений файлов и каталогов.
- **Auditd**: Демон для отслеживания системных событий.

## Antivirus (Антивирус)
- **ClamAV**: Открытое решение для обнаружения вирусов и вредоносного ПО.
- **LMD (Linux Malware Detect)**: Обнаружение вредоносных программ, ориентированное на серверы Linux.

## Disk/Filesystem Encryption (Шифрование файловой системы)
- **dm-crypt**: Система шифрования блочных устройств в Linux.
- **EncFS**: Файловая система с поддержкой шифрования на уровне файлов.
- **fscrypt**: Утилита для шифрования отдельных каталогов.

## Secure Shell (Безопасный доступ по SSH)
- **SSHGuard**: Защита от атак на SSH-серверы.
- **DenyHosts**: Скрипт для предотвращения атак подбора паролей через SSH.
- **fail2ban**: Автоматическое блокирование IP-адресов при множественных неудачных попытках входа.

## VPN (Виртуальные частные сети)
- **IPSec**: Протокол для обеспечения безопасности интернет-протоколов.
- **OpenVPN**: Популярный и надёжный инструмент для организации VPN.
- **WireGuard**: Современный, производительный VPN-протокол.

## Password Security (Безопасность паролей)
- **John the Ripper**: Утилита для взлома и тестирования на слабость паролей.
- **pwgen**: Генератор случайных паролей.

## Network Monitoring (Мониторинг сети)
- **Wireshark**: Инструмент для анализа сетевого трафика.
- **tcpdump**: Утилита для перехвата и анализа сетевых пакетов.
- **Scapy**: Инструмент для манипулирования сетевыми пакетами и тестирования сетей.

## Security Hardening (Укрепление безопасности)
- **SELinux**: Механизм контроля доступа, обеспечивающий дополнительную безопасность на уровне ядра.
- **AppArmor**: Подобный SELinux инструмент для контроля доступа приложений.
- **Grsecurity**: Патчи ядра для усиления защиты.
- **Lynis**: Аудитор безопасности для систем на базе Linux.

## Rootkit Detection (Обнаружение руткитов)
- **chkrootkit**: Утилита для поиска руткитов на Linux-системах.
- **rkhunter**: Инструмент для проверки систем на наличие руткитов.

## Security Auditing (Аудит безопасности)
- **openSCAP**: Фреймворк для проверки соответствия систем требованиям безопасности.
- **openVAS**: Система для сканирования уязвимостей в сети.
- **Nmap**: Инструмент для сканирования сетей и обнаружения открытых портов и уязвимостей.
